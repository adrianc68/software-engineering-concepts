# Fundamentals
* **Activity**: A broad term for any action or set of actions undertaken to achieve a goal.
* **Action**: A specific deed or movement carried out as part of an activity
* **Step**: An individual phase or part of a process or action sequence.
* **Task**: A specific job or piece of work to be completed, often part of a larger project.
* **Method**: A systematic way of doing something, often following a prescribed or established approach.
* **Procedure**: A detailed, formalized series of steps to accomplish a specific task or activity.
* **Function**: The specific role or purpose of something within a system or process.
* **Methodology**: A set of principle and practices that guide how research or tasks are conducted.
* **Technique**: A specific skill or way of doing something, often emphasizing dexterity or expertise.
* **Tactic**: A specific action or strategy designed to achieve a short-term goal, often within a larger plan.
* **Process**: A series of actions or steps taken to achieve a particular end.
* **Model**: A representation of framework that illustrates a concept or system.
* **Principle**: A fundamental truth, or proposition that serves as the foundation for a system of belief or behavior.
* **Model**: A representation or framework that illustrates a concept or system.
* **Meta model**: A model that describes the structure and behavior of other models, often used to analyze systems.
* **Process flow**: A visual representation of the steps involved in a process, showing the sequence and interactions.
* **Data model**: A conceptual representation of data structures, relationships, and constraints used to organize and manage data.
* **Component**: a modular, deployable and replaceable part of a system that encapsulates implementation and exposes a set of interfaces.
* **Granularity**: The level of detail or specificity in data or information; finer granularity means more detailed data.
* **Partitioning or separation of concerns**: The practice of dividing a system into distinct sections to manage complexity and improve maintainability.
* **Data drive method**: An approach that relies on data analysis and insights to guide decisions and actions.
* **Pattern driven method**: A technique that uses established patterns or templates to solve problem or design systems.
* **Object oriented method**: A programming paradigm based on the concept of "objects", which combine data and behavior, promoting reused and modularity.

* **Error**: A mistake or inaccuracy in a system or component to perform its intended function, often resulting from one or more errors.
* **Failure**: The inability of a system or component to perform its intended function, often resulting from one or more errors.
* **Bug**: A defect or flaw in software code that causes it to behave unexpectedly or incorrectly
* **Flaw**: This typically refers to a defect or imperfection in something, such as a design or implementation. 

* Syntax: It refers to a set of rules that govern the structure of sentences or statements in a language, focusing on how words and symbols are arranged.
* Semantic: Involves the meaning of those sentences or statements, exploring how the arrangement of words conveys specific ideas or concepts.

* **Legacy software**: Outdated software system that are still in use but may not meet current standards or technologies.

Concepts that transcend programming languages and specific technologies:\
* **Interfaces**: Abstract boundaries that define interactions between different software components, allowing for communication without exposing internal details.
* **Conventions and templates**: Standardized practices or structures used to ensure consistency and clarity in coding and design across projects.
* **Layering**: A design principle that separates different concerns of functionalities into distinct layers, promoting modularity and easier maintenance.
* **Algorithmic complexity**: A measure of the efficiency of an algorithm, typically expressed in terms of time
* **Hashing**: A technique that converts input data into a fixed-size strings of characters, which is typically used for quick data retrieval and integrity verification.
* **Caching**: A method of storing frequently accessed data in a temporary storage area to speed up retrieval and integrity verification.
* **Concurrency**: The ability to execute multiple tasks or processes simultaneously, improving the efficiency and responsiveness of applications.
* **Security**: The measures and practices implemented to protect systems and data from unauthorized access, misuse, or damage.
* **Relational databases**: Structured systems for storing and managing data using tables, where relationships between data items can be defined, allowing for complex queries and data integrity.

* Static models: Represent the structure and organization of the system at a specific moment, without considering behavior over time.
* Dynamic models: Focus on the behavior of the system over time and how it responds to different events
# Software Application Domains

## System Software

System software acts as a bridge between hardware and application software. It manages hardware resources and provides essential services like file management, memory management, and task scheduling. Examples include Windows, macOS, Linux, and device drivers.
## Application Software

This software is designed for end-users to perform specific tasks, such as word processing, spreadsheet calculations, or graphic design. Examples include Microsoft Office, Adobe Photoshop, and customer relationship management (CRM) systems. They enhance productivity and meet particular business requirements.
## Engineering/Scientific Software

These programs support calculations, simulations, and analyses across various scientific and engineering fields. They often include specialized tools for tasks like finite element analysis, computational fluid dynamics, and statistical analysis. Examples are MATLAB, ANSYS, and LabVIEW.
## Embedded Software

Embedded software is tailored to operate within specific hardware systems, controlling functions and enabling user interaction. It’s commonly found in consumer electronics, automotive systems, and industrial machines. Examples include firmware in smart appliances and software in medical devices.
## Product-line Software

This type of software is designed to meet the needs of different customers while maintaining a common architecture. It allows for rapid customization and deployment across various markets, such as CRM systems that can be tailored to specific industries.
## Web/Mobile Applications

Web applications are hosted on servers and accessed through browsers, while mobile applications are installed on devices. Both types leverage internet connectivity for functionality, allowing for features like real-time updates and remote access. Examples include Google Docs (web) and Instagram (mobile).
### Artificial Intelligence Software

This software employs advanced algorithms to analyze data, recognize patterns, and make decisions. It includes machine learning frameworks and natural language processing tools that enable applications like chatbots, recommendation systems, and predictive analytics. Examples are TensorFlow and IBM Watson.
### WebApps

WebApps are optimized for use in browsers, providing a seamless experience without installation. They often use HTML, CSS, and JavaScript, and can be responsive to different devices. Examples include Trello and Slack, which facilitate collaboration and project management.
### Mobile Applications

Designed specifically for mobile devices, these applications take advantage of features like GPS, camera, and touch interfaces. They can be native (built for a specific platform) or hybrid (cross-platform). Examples include WhatsApp and Spotify, which offer rich user experiences tailored for mobile.
### Cloud Computing

This model enables users to access and store data and applications over the internet instead of on local servers or personal computers. It offers scalability, flexibility, and cost-effectiveness, supporting various services such as Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS). Examples include AWS, Google Cloud, and Microsoft Azure.

# The software

Software are
1. Instructions that when executed provide desired features, functions and performance. 
2. Data structures that enable the programs to adequately manipulate information.
3. Descriptive information in both hard copy and virtual forms that describes the operation and use of the programs.

Computer software is the product that software professionals build and then support over the long term.

Software is important because it affects nearly every aspect of our lives and has become pervasive in our commerce, our culture and our everyday activities.

Why is it important?
Software would enable the creation of new technologies, the extension of existing technologies and the radical change in older technologies.

We need to produce a high-quality product and the only way we can accomplish that in a repeatable fashion is to adapt our own subset of software engineering techniques.

Today the software has a dual role. It is a product and a vehicle. Where the sofftware is a information transformer. As a vehicle used to deliver the product, software acts as the basis fort the control of the computer, the communication of information, and the creation and control of other programs.

Every software project is precipitated by some business need—the need to correct a defect in an existing application; the need to adapt a "legacy system" to a changing business environment; the need to extend the functions and features of an existing application; or the need to create a new product, service or system. At the beginning of a software project, the business need is often expressed informally as part of a simple conversation. 

# Software Engineering

Software Engineering is:

> A systematic, disciplined, and quantifiable approach to the development operation and maintenance of software
\- Roger Pressman

> A discipline that encompasses all aspects of software production, from initial conception through to maintenance and eventual retirement

\- Ian Sommerville

> (1) The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of sotfware: that is, the application of engineering to software (2). The study of approaches as in (1)

\- IEEE 

Software Engineering encompasses a process, a collection of methods (practice) and an array of tools that allow professionals to build high-quality computer software.

Software Engineering is important because it enables us to build complex systems in a timely manner and with high quality.

The work product is the set of programs, content (data) and other work products that are computer software.

# The Software Process

The foundation for software engineering is the process layer. The software engineering process is the glue that holds the technology layers together and enables rational and timely development of computer software. 

![](images/Pasted%20image%2020240926171219.png)

**Process** defines a framework that must be established for effective delivery of software engineering technology. The software process form the basis for management control of software products and establishes the context in which technical methods are applied, work products (models, documents, data, reports, forms, etc) are produced, milestones are established, quality is ensured and change is properly managed.

Software Engineering methods provide the technical how-to's for building software. Methods encompass a broad array of tasks that include communication, requirements analysis, design modeling, program construction, testing and support. Software Engineering methods rely on a set of basic principles that govern each area of the technology and include modeling activities and other descriptive techniques.

Software Engineering tools provide automated or semi-automated support for the process and the methods. When tools are integrated so that information created by one tool can be used by another, a system for the support of software development, called computer-aided software engineering is established.

A **process** is a collection of activities, actions and tasks that are performed when some work product is to be created. An **activity** strives to achieve a broad objective and is applied regardless of the application domain, size of the project, complexity of the effort, or degree of rigor with which software engineering is to be applied.\

An **action** encompasses a set of tasks that produce a major work product.

A **task** focuses on a small but well-defined objective that produces a tangible outcome.

A process it's an adaptable approach that enables the people of doing the work to pick and choose the appropriate set of work actions and tasks.

## The Process Framework

A Process framework establishes the foundation for a complete software engineering process by identifying a small number of **framework** activities that are applicable to all software projects, regardless of their size or complexity.

The process framework encompasses a set of **umbrella activities** that are applicable across the entire software process. A generic process framework for software engineering encompasses five activities:

- **Communication**: The goal is to understand stakeholders' objectives for the project and gather requirements that help define the software's features and functions.
- **Planning**: In this phase, strategies for software development are developed, including defining necessary resources, estimating time and costs, assigning tasks, and creating a schedule. Potential risks are also identified, and actions are planned to mitigate them.
- **Modeling**: This involves creating abstract representations of the system, including diagrams, data models, and architectures. It helps visualize and understand how the software will function, ensuring it meets the defined requirements.
- **Construction**: During this activity, the actual software implementation takes place. Code is written, unit tests are conducted, and the system is integrated. The focus is on ensuring that the software meets quality standards and client requirements.
- **Deployment**: This phase involves delivering the software to the end users. It includes installation, configuration, and necessary training for users to effectively utilize the system. Feedback is also gathered, and future updates may be planned.

For many software projects, framework activities are applied iteratively as a project progresses. Each iteration produces a **software increment** that provides stakeholder's with a subset of overall software features and functionality.

### Umbrella Activities

Software Engineering process framework activities are complemented by a number of umbrella activities. They help a software team manage and control progress, quality, change and risk. Typical umbrella activities include:
- **Software Project Tracking and Control**: Involves monitoring project progress against plans, ensuring that milestones are met, and making adjustments as needed.
- **Risk Management**: Identifying, analyzing, and mitigating risks that could impact project success, ensuring that potential issues are addressed proactively.
- **Software Quality Assurance**: Establishing processes and standards to ensure the software meets quality requirements throughout development, often involving audits and reviews.
- **Technical Reviews**: Conducting evaluations of project artifacts (like design documents and code) to ensure they meet requirements and standards, promoting early detection of issues.
- **Measurement**: Gathering and analyzing data related to the software process and product to assess performance, productivity, and quality, aiding in informed decision-making.
- **Software Configuration Management**: Managing changes to software artifacts, ensuring consistency and traceability throughout the development lifecycle.
- **Reusability Management**: Identifying and promoting the reuse of software components to enhance efficiency and reduce development time and costs.
- **Work Product Preparation and Production**: Involves the creation and maintenance of documents and deliverables throughout the project, ensuring that all necessary outputs are produced effectively.
### Project Adaptation

A process adopted for one project might be significantly different than a process adopted for another project. Among the differences are:
* Overall flow of activities, actions and tasks and the interdependencias among them.
* Degree to which actions and tasks are defined within each framework activity.
* Degree to which work products are identified and required.
* Manner in which quality assurance activities are applied.
* Manner in which project tracking and control activities are applied.
* Overall degree f detail and rigor with which the process is described.
* Degree to which the customer and other stakeholders are involved with the project.
* Level of autonomy given to the software team.
* Degree to which team organization and roles are prescribed.

### Essence of Practice 

In general, the essence of practice or software engineering are:
1. Understand the problem (communication and analysis)
2. Plan a solution (modeling and software design)
3. Carry out the plan (code generation)
4. Examine the result for accuracy (testing and quality assurance)

| Activities                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Understand the problem          | It's worth spending a little time answering a few simple questions:<br>-Who has a stake in the solution to the problem? That is, who are the stakeholders?<br>-What are the unknowns? What data, functions and features are required to properly solve the problem.<br>-Can the problem be compartmentalized? Is it possible to represent smaller problems that may be easier to understand?<br>-Can the problem be represented graphically? Can an analysis model be created?                                                            |
| Plan a solution                 | You do a little design:<br>-Have you seen similar problems before? Are there patterns that are recognizable in a potential solution? Is there existing software that implements the data, functions and features that are required?<br>-Has a similar problem been solved? If so, are elements of the solution reusable?<br>-Can subproblems be defined? If so, are solutions readily apparent. for the subproblems?<br>-Can you represent a solution in a manner that leads to effective implementation? Can a design model be created?` |
| Carry out the plan              | The plan will allow you to proceed without getting lost.<br>-Does the solution conform to the plan? Is source code traceable to the design model?<br>-Is each component part of the solution provably correct? Has the design and code been reviewed, or better, have correctness proofs been applied to the algorithm?                                                                                                                                                                                                                   |
| Examine the result for accuracy | you can be sure that you've designed a sufficient number of test to uncover as many errors as possible.<br>-Is it possible to test each component part of the solution? Has a reasonable testing strategy been implemented?<br>-Does the solution produce results that conform to the data, functions and features that are required? Has the software been validated against all stakeholder requirements?                                                                                                                               |


# Software Process Structure

The software process is represented by the next figure. Referring to the figure, each framework activity is populated by a set of software engineering actions. Each software engineering action is defined by a task set that identifies the work tasks that are to be completed, the work products that will be produced, the quality assurance points that will be required, and the milestones that will be used to indicate progress.

![](images/Pasted%20image%2020240927163310.png)

The software process incorporates five framework activities—communication, planning, modeling, construction and deployment that are applicable to all software projects. In addition, a set of umbrella activities—project tracking and control, risk management, quality assurance, configuration management, technical reviews and others—are applied throughout the process.

All the models have an important aspect called **process flow**—describes how the framework activities and the actions and tasks that occur within each framework activity are organized with respect to sequence and time 

| Process flow    | Description                                                                                                                                |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| A linear        | It executes each of the five framework activities in sequence, beginning with communication and culminating with deployment.               |
| A Iterative     | It repeats one or more of the activities before proceeding to the next.                                                                    |
| An evolutionary | It executes the activities in a circular manner. Each circuit through the five activities leads to a more complete version of the software |
| A parallel      | It executes one or more activities in parallel with other activities                                                                       |

![](images/Pasted%20image%2020240927163836.png)

Each software engineering action can be represented by a number of different task sets—each a collection of software engineering work tasks, related work products, quality assurance points and project milestones.

A task set defines the actual work to be done to accomplish the objectives of a software engineering action. For example elicitation (requirements gathering) is an important software engineering action that occurs during the communication activity. The goal of requirements gathering is to understand what various stakeholders want from the software that is to be built.
For a small relative simple project, the task set for requirements gathering might look likes this:
1. Make a list of stakeholders for the project
2. Invite all stakeholders to an informal meeting
3. Ask each stakeholder to make a list of features and functions required.
4. Discuss requirements and build a final list
5. Prioritize requirements
6. Note areas of uncertainty.
The software team chooses the task set that will allow it to achieve the goal of each action and still maintain quality and agility.

### Process Assessment and improvement

The existence of a software process is no guarantee that software will be delivered on time, that it will meet the customer's needs or that it will exhibit the technical characteristics that will lead to long-term quality characteristics. Process patterns must be coupled with solid software engineering practica. In addition, the process itself can be assessed to ensure that it meets a set of basic process criteria that have been shown to be essential for a successful software engineering. 

A number of different approaches to software process assessment and improvement have been proposed over the past few decades:

####  SCAMPi (Standard CMMI Appraisal Method for Process Improvement)

SCAMPi is an evaluation method used to measure an organization's process maturity based on the CMMI (Capability Maturity Model Integration). It consists of:
- **Process Evaluation**: Conducts a detailed assessment of current processes against CMMI best practices.
- **Continuous Improvement**: Identifies improvement areas and provides a framework for developing action plans for process enhancement.
- **Maturity Classification**: Offers a maturity level that helps organizations understand their current position and plan for future improvements.

#### CMM-Based Appraisal for Internal Process Improvement

This approach focuses on the internal evaluation of an organization’s processes using the CMM (Capability Maturity Model). It includes:
- **Self-Assessment**: Organizations perform self-assessments to identify strengths and weaknesses.
- **Improvement Focus**: Sets improvement goals based on assessment results, fostering a culture of continuous enhancement.
- **Adoption of Best Practices**: Organizations implement recommended practices to achieve higher maturity levels.

#### SPICE (ISO/IEC 15504)

SPICE is an international standard for assessing processes in software development. It includes:
- **Process Assessment**: Provides a framework for evaluating the capability and maturity of software processes.
- **Assessment Model**: Allows organizations to assess their processes, identify improvement areas, and establish action plans.
- **Focus on Outcomes**: Emphasizes the effectiveness of processes in delivering quality results and meeting customer requirements.

#### ISO 9001:2000 for Software

ISO 9001:2000 is a quality management standard that also applies to the software industry. Its features include:
- **Quality Management**: Establishes requirements for a quality management system, ensuring that the organization meets quality standards in its processes and products.
- **Customer Focus**: Prioritizes customer satisfaction and continuous process improvement.
- **Documentation and Control**: Requires documentation of processes and procedures, ensuring consistent and quality practices.


## Management Process 

### Dynamic Systems Development Method (DSDM)

### RUP
## Process models

Process models were originally proposed to bring order to the chaos of software development. A process model outlines the stages of software development, the tasks to be performed, the roles involved, and the interactions between different components of the process. 

Software engineers, project managers, and process improvement specialists often develop these models. Companies may tailor existing models to fit their specific needs, taking into account their workflow, team structure, and project requirements. Organizations like IEEE, ISO, and SEI (Software Engineering Institute) may also define models as part of broader standards.

Process models are important because they provide:
- **Structure and Order**: Process models help organize the software development process, reducing chaos and ambiguity.
- **Improved Efficiency**: By defining clear steps and responsibilities, models enhance productivity and streamline workflows.
- **Risk Management**: They allow for better identification and mitigation of risks at various stages of development.
- **Quality Assurance**: Process models often include quality checkpoints, ensuring that the software meets defined standards and requirements.
- **Facilitates Communication**: They provide a common framework and language for team members, stakeholders, and clients, improving collaboration and understanding.
- **Adaptability**: Models can be tailored to suit different types of projects, making them flexible and relevant in various contexts.

All software process models can accommodate the generic framework activities described before, but each applies a different emphasis to these activities and defines a process flow that invokes each framework activity in a different manner.

### Linear  Models

#### Waterfall

The Waterfall model is a sequential development process where each phase must be completed before moving on to the next. It typically consists of the following stages:

1. **Requirements Analysis**: Gathering and documenting requirements from stakeholders.
2. **System Design**: Creating a system architecture and design based on the requirements.
3. **Implementation**: Writing the actual code to build the software.
4. **Testing**: Testing the software to ensure it meets the specified requirements.
5. **Deployment**: Addressing any issues or updates after deployment.
6. **Maintenance**: Addressing any issues, bugs, or updates that arise after the software is deployed. This phase ensures the software remains functional and relevant over time, involving activities like patching bugs, enhancing features, and adapting to new requirements.

**Characteristics**:

- **Predictability**: Each phase has specific deliverables and a timeline.
- **Documentation**: Extensive documentation is produced at each stage.
- **Rigidity**: Changes in requirements after the initial phases can be costly and challenging to implement.

**Use Cases**: Best suited for projects with well-defined requirements and low likelihood of changes.

![](images/Pasted%20image%2020240927171431.png)

#### The V-Model

The V-Model, or Verification and Validation Model, is an extension of the Waterfall model that emphasizes the relationship between development stages and corresponding testing phases. Its structure resembles the letter "V":
1. **Requirements Analysis**: Similar to Waterfall, it begins with gathering requirements.
2. **System Design**: High-level and detailed design phases.
3. **Implementation**: Code development follows the design phases.

**Validation Phases**: On the right side of the "V," each development phase has a corresponding testing phase:
- **Unit Testing**: Tests individual components for functionality.
- **Integration Testing**: Checks how different components work together.
- **System Testing**: Validates the complete system against requirements.
- **User Acceptance Testing (UAT)**: Ensures the software meets user expectations.

**Characteristics**:
- **Testing Emphasis**: Each phase is associated with specific tests to validate functionality and requirements.
- **Clear Structure**: Like the Waterfall, but with a stronger focus on verification and validation.

**Use Cases**: Ideal for projects requiring high reliability and where each phase's outputs can be thoroughly tested before proceeding.

![](images/Pasted%20image%2020240927171532.png)

### Iterative  Models
#### Spiral

The Spiral model combines iterative development with a focus on risk management. It consists of repeated cycles (or spirals) through the following phases:

1. **Planning**: Identify objectives, constraints, and alternatives.
2. **Risk Analysis**: Assess risks and develop strategies to mitigate them.
3. **Engineering**: Develop and test the next version of the product.
4. **Evaluation**: Obtain feedback from stakeholders and refine the project.

**Characteristics**:

- **Risk Focus**: Emphasizes identifying and mitigating risks at each cycle.
- **Flexibility**: Allows for adjustments based on feedback and changing requirements.
- **Iterative**: Each spiral builds on the previous one, gradually increasing the product's functionality.

**Use Cases**: Suitable for large, complex projects where risk management is critical and requirements may evolve.

![](images/Pasted%20image%2020240927221428.png)

### Incremental Models 

#### Incremental

The Incremental model involves developing software in small, manageable sections called increments. Each increment adds functional capabilities to the existing product. The process includes:
1. **Requirements Definition**: Identify all requirements, which are then divided into increments.
2. **Increment Development**: Develop and implement one increment at a time.
3. **Integration**: Combine the increments into a complete system after each development cycle.
4. **Testing**: Test each increment as it is developed and integrated.

**Characteristics**:

- **Gradual Delivery**: Functional components are delivered in stages, allowing for early user feedback.
- **Flexibility**: New requirements can be added in subsequent increments.
- **Reduced Risk**: Issues can be identified and resolved incrementally rather than all at once.

**Use Cases**: Ideal for projects with clear requirements that can evolve, where early delivery of functionality is beneficial.


![](images/Pasted%20image%2020240927221807.png)

### Evolutionary Process Models

#### Prototyping

Prototyping involves creating a preliminary version of the software (a prototype) to gather user feedback before final development. The process includes:
1. **Requirement Gathering**: Collect initial requirements from users.
2. **Prototype Development**: Build a working model based on the gathered requirements.
3. **User Evaluation**: Present the prototype to users for feedback and suggestions.
4. **Refinement**: Update the prototype based on user feedback, iterating until requirements are finalized.

**Characteristics**:
- **User-Centric**: Engages users early and often, leading to better alignment with their needs.
- **Flexible**: Allows for quick changes based on feedback.
- **Risk Reduction**: Helps identify issues early in the development process.

**Use Cases**: Useful when requirements are unclear or subject to change, and user involvement is critical.

![](images/Pasted%20image%2020240927221940.png)
### Concurrent Models

#### Concurrent Development Model

Concurrent models allow for the simultaneous execution of various development activities, promoting collaboration and efficiency. Key aspects include:
1. **Parallel Development**: Multiple components or subsystems are developed at the same time, often with cross-functional teams.
2. **Integration**: Continuous integration of components as they are developed, allowing for immediate testing and feedback.
3. **Flexibility**: Teams can adapt to changes quickly without waiting for one phase to complete before starting another.

**Characteristics**:
- **Time Efficiency**: Reduces overall development time by overlapping activities.
- **Collaborative**: Encourages teamwork and communication among different functions.
- **Complex Management**: Requires effective coordination to manage dependencies and ensure consistency.

**Use Cases**: Suitable for complex projects with multiple teams working on different parts of the system, such as large enterprise applications.

![](images/Pasted%20image%2020240927222043.png)
### Specialized Process Models
#### Component-Based Development

Component-Based Development (CBD) is an approach that emphasizes the use of reusable software components to build applications. This model focuses on assembling pre-existing components rather than developing everything from scratch. Key aspects include:
1. **Component Identification**: Identify and define reusable components based on functional requirements.
2. **Component Integration**: Integrate these components into a larger system, ensuring they work together seamlessly.
3. **Customization**: Adapt and modify components as needed to fit specific project requirements.
4. **Testing and Validation**: Test the integrated system to ensure all components function correctly together.

**Characteristics**:
- **Reusability**: Encourages the use of established components, reducing development time and effort.
- **Modularity**: Promotes a modular architecture, making it easier to maintain and update individual components.
- **Reduced Risk**: Using proven components can lower the risk of defects and improve overall software quality.

**Use Cases**: Ideal for large-scale systems, enterprise applications, and situations where rapid development and deployment are necessary. CBD is particularly beneficial in environments with a library of existing components to leverage.

![](images/Pasted%20image%2020240927222252.png)

#### The Formal Methods Model

The Formal Methods Model is a mathematical approach to software development that emphasizes the use of formal specifications and verification techniques. This model aims to ensure software correctness and reliability through rigorous mathematical analysis. Key aspects include:

1. **Formal Specification**: Define the system's requirements and behavior using formal languages and mathematical notations. This provides a precise and unambiguous description of what the software is supposed to do.
2. **Verification**: Use formal methods to prove that the software design and implementation adhere to the specifications. This can involve techniques such as model checking, theorem proving, or static analysis.
3. **Refinement**: Transform formal specifications into executable code through a series of well-defined steps, ensuring that each transformation preserves correctness.
4. **Documentation**: Maintain comprehensive documentation of specifications, proofs, and design decisions to support understanding and future modifications.
    
**Characteristics**:
- **Rigorous**: Provides a high level of assurance regarding the correctness and reliability of the software.
- **Complexity Handling**: Helps manage complexity in critical systems, such as safety-critical and mission-critical applications.
- **Tool Support**: Often involves specialized tools for specification, verification, and analysis.

**Use Cases**: Particularly useful in domains where safety and correctness are paramount, such as aerospace, medical devices, and banking systems

![](images/Pasted%20image%2020240927222330.png)
#### Aspect-Oriented Software Development

Aspect-Oriented Software Development (AOSD) is a programming paradigm that aims to enhance modularity by allowing the separation of cross-cutting concerns. Cross-cutting concerns are aspects of a program that affect multiple modules and can lead to code tangling and scattering, making the software harder to maintain. Key aspects of AOSD include:
1. **Aspects**: These are modular units that encapsulate cross-cutting concerns, such as logging, security, or error handling, that typically affect multiple parts of an application.
2. **Join Points**: Specific points in the program execution where an aspect can be applied, such as method calls or object instantiations.
3. **Advice**: Code that is executed at specified join points. It defines the behavior that should occur before, after, or around the execution of a method.
4. **Weaving**: The process of integrating aspects with the main program code. This can be done at compile-time, load-time, or runtime, depending on the AOSD framework or language used.
    
**Characteristics**:
- **Separation of Concerns**: Promotes better organization of code by isolating concerns that cut across multiple modules, leading to cleaner and more maintainable code.
- **Reusability**: Aspects can be reused across different applications or modules, reducing redundancy.
- **Flexibility**: Allows developers to add, modify, or remove aspects without altering the core business logic of the application.

**Use Cases**: AOSD is particularly useful in large systems where cross-cutting concerns are prevalent, such as enterprise applications, distributed systems, and applications requiring extensive logging or security features.

![](images/Pasted%20image%2020240927222706.png)

### Agile Process Models

#### Scrum 

Scrum is an agile framework for managing and completing complex projects, primarily in software development. It emphasizes iterative progress, collaboration, and flexibility, allowing teams to respond quickly to changes and deliver high-quality products.

**Characteristics**:
- **Roles**: Key roles include the Scrum Master (facilitator), Product Owner (stakeholder representative), and Development Team (cross-functional members).
- **Sprints**: Work is divided into time-boxed iterations called sprints, typically lasting 1-4 weeks.
- **Backlog**: The Product Backlog is a prioritized list of features and tasks, while the Sprint Backlog contains items selected for the current sprint.
- **Ceremonies**: Includes regular ceremonies such as Sprint Planning, Daily Stand-ups, Sprint Reviews, and Sprint Retrospectives to ensure continuous communication and improvement.

**Use Cases**: Scrum is well-suited for projects with evolving requirements, where teams need to deliver incremental value. It’s commonly used in software development but can be applied to various industries for managing projects that benefit from flexibility and rapid feedback.

![](images/Pasted%20image%2020240927230819.png)

#### Extreme Programming (XP)

Extreme Programming (XP) is an agile software development methodology that emphasizes technical excellence and customer satisfaction. Key characteristics include:

1. **Short Iterations**: Development occurs in small cycles, typically lasting one to three weeks, allowing for frequent feedback and adjustments.
2. **Pair Programming**: Two developers work together at one workstation, enhancing code quality and facilitating knowledge sharing.
3. **Test-Driven Development (TDD)**: Writing tests before the code ensures that the software meets requirements and facilitates easier refactoring.
4. **Continuous Integration**: Code is integrated and tested frequently to identify issues early and reduce integration problems.
5. **Customer Involvement**: The customer is an integral part of the team, providing feedback and clarifications throughout the development process.

**Use Cases**: XP is particularly beneficial for projects with rapidly changing requirements and a strong need for high-quality code.

![](images/Pasted%20image%2020240927223837.png)
#### Feature-Driven Development (FDD)

Feature-Driven Development (FDD) is an agile methodology focused on delivering tangible, working features in a structured manner. Key characteristics include:

1. **Feature-Centric Approach**: The development process is organized around the delivery of specific features, each providing value to the end user.
2. **Short Iterations**: Features are developed in short iterations, typically two weeks long, ensuring quick delivery and feedback.
3. **Modeling**: An initial model of the system is created, which helps in understanding the scope and relationships between features.
4. **Roles and Responsibilities**: FDD defines specific roles, including Chief Architect, Development Manager, and Feature Teams, to enhance collaboration and accountability.
5. **Regular Builds**: Frequent builds of the software ensure that features are integrated and tested early in the development process.

**Use Cases**: FDD is well-suited for larger projects where features can be clearly defined and prioritized, allowing teams to focus on delivering value incrementally.

![](images/Pasted%20image%2020240927223904.png)

### PSP and TSP

#### Personal Software Process

The Personal Software Process (PSP) is a structured framework that helps individual software engineers improve their personal software development practices. It focuses on self-improvement through the use of defined processes, measurements, and quality management techniques. The goal is to increase individual productivity and software quality.

Characteristics:
- **Defined Processes:** PSP includes specific phases such as planning, development, and post-mortem analysis.
- **Measurement:** Encourages tracking of metrics like time spent on tasks, defects, and productivity.
- **Self-Management:** Promotes personal accountability and continuous improvement.
- **Quality Focus:** Emphasizes defect prevention and quality assurance techniques.
- **Structured Documentation:** Involves documenting work processes, estimates, and outcomes for analysis.

**Use Cases**: PSP is ideal for individual developers looking to enhance their coding skills and time management, reduce defects, and demonstrate a commitment to quality and professional growth.

![](images/Pasted%20image%2020240927225727.png)

#### Team Process Process

The Team Software Process (TSP) builds on the principles of PSP but focuses on improving software development practices at the team level. It provides a framework for teams to define, implement, and manage their software development processes collectively, enhancing collaboration, productivity, and product quality.

**Characteristics**:
- Team-centric approach with defined roles
- Structured process for planning and reviews
- Emphasis on metrics and performance analysis
- Strong focus on quality management

**Use Cases**: TSP is well-suited for software teams managing complex projects, enabling them to collaborate effectively, plan with clear milestones, and ensure higher quality outputs through systematic processes.

![](images/Pasted%20image%2020240927225752.png)

# Software Engineer Principles

Principles in software engineering are essential because they guide the design, development and maintenance of software systems in an effective and efficient manner. They help to you to establish a mind-set for solid software engineering practice.

## General Principles

| Principle                            | Description                                                                                                                                                                                                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| The Reason It All Exists             | A software system exist for one reason: to provide value to its users. All decisions should be made with this in mind. "Does this add real value to the system? If answer is no, don't do it"                                                                                  |
| KISS (Keep It Simple, Stupid)        | All design should be as simple as possible, but no simpler. The more elegant designs are usually the more simple ones. Simple also does not mean "quick and dirty"                                                                                                             |
| Maintain the Vision                  | A clear vision is essential to the success of a software project. Without one a project almost unfailingly ends up being "or two or more minds" about itself. Without conceptual integrity, a system threatens to become a patchwork of incompatible designs.                  |
| What You produce, Other Will Consume | Always specify, design and implement knowing someone else will have to understand what you are doing.                                                                                                                                                                          |
| Be Open to the Future                | A system with a long lifetime has more value. Never design yourself into a corner. Always ask "what if" and prepare for all possible answers by creating system that solve the general problema, not just the specific one.                                                    |
| Plan Ahead for Reuse                 | Reuse saves times and effort. There are many techniques to realize reuse at every level of the system development process. Planning ahead for reuse reduces the cost and increases the value of both the reusable components and the systems into which they are incorporated. |
| Think                                | Placing clear, complete thought before action almost always produce better results. When you think about something, you are more likely to do it right.                                                                                                                        |

## Core Principles

Core Principles establish a collection of values and rules that serve as a guide as you analyze a problema, design a solution, implement and test the solution, and ultimately deploy the software in the user community. 
### Principles That Guide Process

The following set of core principles can be applied to the framework, and by extension, to every software process.

| Principles                                              | Description                                                                                                                                                                                                                      |
| ------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Be Agile                                                | Every aspect of the work you do should emphasize economy of action. Keep your technical approach as simple as possible, keep the work products you produce as concise as possible, and make decisions locally whenever possible. |
| Focus on quality at every step                          | The exit condition for every process activity, action and task should focus on the quality of the work product has been produced.                                                                                                |
| Be ready to adapt                                       | Process is not a religious experience, and dogma has no place in it When necessary, adapt your approach to constraints imposed by the problem, the people and the project itself.                                                |
| Build an effective team                                 | Build a self-organizing team that has mutual trust and respect                                                                                                                                                                   |
| Establish mechanisms for communication and coordination | Projects fail because important informations falls into the cracks and/or stakeholders fail to coordinate their efforts to create a successful end product.                                                                      |
| Manage Change                                           | The approach may be formal or informal, but mechanisms must be established to manage the way changes are requested, assessed, approved and implemented.                                                                          |
| Assess risk                                             | It's essential that you establish contingency plans.                                                                                                                                                                             |
| Create work products that provide value for others      | Every work product that is produced as part of software engineering practice will be passed on to someone else.                                                                                                                  |

### Principles That Guide Practice

You should adopt a set of core principles that guide your technical work. These principles have merit regardless of the analysis and design methods that you apply, the construction techniques that you use or the verification and validation approach that you choose.

| Principle                                                                                     | Description                                                                                                                                                                                                      |
| --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Divide and conquer                                                                            | A large problem is easier to solve if it is subdivided into a collection of elements (or concerns)                                                                                                               |
| Understand the use of abstraction                                                             | Is a simplification of some complex element of a system used to communicate meaning in a single phrase. The intent of an abstraction is to eliminate the need to communicate details.                            |
| Strive for consistency                                                                        | Suggests that a familiar context makes software easier to use.                                                                                                                                                   |
| Focus on the transfer of information                                                          | Software is about information transfer. In every case, information flows across an interface, and as a consequence, there are opportunities for error, or omission or ambiguity.                                 |
| Build software that exhibits effective modularity                                             | Modularity must be effective. That is, each module should focus exclusively on one well-constrained aspect of the system. It should be cohesive in its function and/or constrained in the content it represents. |
| Look for patterns                                                                             | The use of design patterns can be applied to wider systems engineering and systems integration problems, by allowing components in complex systems to evolve independently.                                      |
| When possible, represent the problem and its solution from a number of different perspectives | It is more likely that greater insight will be achieved and that errors and omissions will be uncovered. Each provides a different perspective of the problem and its requirements.                              |
| Remember that someone will maintain the software                                              | These maintenance activities can be facilitated if solid software engineering practice is applied throughout the software process.                                                                               |
|                                                                                               |                                                                                                                                                                                                                  |

## Principles That Guide Each Framework Activity

### Communication Principles

| Principle                                                                                                                                                           | Description                                                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Listen                                                                                                                                                              | Never become contentious in your word or actions (e.g. rolling your eyes or shaking your head) as a person is talking.                                                                      |
| Prepare before you communicate                                                                                                                                      | Spend the time you understand the problem before you meet with others.                                                                                                                      |
| Someone should facilitate the activity                                                                                                                              | Every communication meeting should have a leader to keep the conversation moving in a productive direction to mediate any conflict that does occur, and to ensure as a focus for discussion |
| Face-to-face communication is best                                                                                                                                  | But it usually works better when some other representation of the relevant information is present.                                                                                          |
| Take notes and document decisions                                                                                                                                   |                                                                                                                                                                                             |
| Strive for collaboration                                                                                                                                            |                                                                                                                                                                                             |
| Stay focused: modularized your discussion                                                                                                                           | The facilitator should keep the conversation modular, leaving one topic only after it has been resolved.                                                                                    |
| If something is unclear, draw a picture                                                                                                                             | A sketch or drawing can often provide clarity when words fail to do the job.                                                                                                                |
| Once you agree to something, move on. If you can't agree to something, move on. IF a feature or function is unclear and cannot be clarified at the moment, move on. |                                                                                                                                                                                             |
| Negotiation is not a contest or a game. It works best when both parties win.                                                                                        |                                                                                                                                                                                             |
 
### Planning Principles

The planning activity encompasses a set of management and technical practices that enable the software team to define a road map as it travels toward its strategic goal and tactical objectives.

| Principle                                                  | Description                                                                                                                                                                                                                                                                                                     |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Understand the scope of the project                        | It's impossible to use a road map if you don't know where you're going. Scope provides the software team with a destination.                                                                                                                                                                                    |
| Involve stakeholders in the planning activity              | Stakeholders define priorities and establish project constraints. To accommodate these realities, software engineers must often negotiate order of delivery, time lines and other project-related issues.                                                                                                       |
| Recognize that planning is iterative                       | As work beings, it is very likely that things will change. As a consequence, the plan must be adjusted to accommodate these changes. In addition, iterative, incremental process models dictate replanning after the delivery of each software increment based on feedback received from users.                 |
| Estimate based on what you know                            | The intent of estimation is to provide an indication of effort, cost and task duration based on the team's current understanding of the work to be done.                                                                                                                                                        |
| Consider risk as you define the plan                       | The project plan should be adjusted to accommodate the likelihood that one or more of these risks will occur.                                                                                                                                                                                                   |
| Be realistic                                               | People don't work 100 percent of every day.                                                                                                                                                                                                                                                                     |
| Adjust granularity as you define the plan                  | Granularity refers to the level of detail that is introduced as a project plan is developed. A high granularity plan provides significant work task detail that is planned over relatively short time increments. A low granularity plan provides broader work tasks that are planned over longer time periods. |
| Define how you intend to ensure quality                    | The plan should identify how the software teams intends to ensure quality. If technical review's are to be conducted, they should be scheduled. If pair programming is to be used during construction, it should be explicitly defined within the plan.                                                         |
| Describe how you intend to accommodate change              | Even the best planning can be obviated by uncontrolled change. You should identify how changes are to be accommodated as software engineering work proceeds.                                                                                                                                                    |
| Track the plan frequently and make adjustments as required | Software projects fail behind schedule one day at a time. Therefore, it makes sense to track progress on a daily basis, looking for problem areas and situations in which scheduled work does not conform to actual work conducted                                                                              |

### Modeling Principles

When the entity to be built is software, our model must take a different form. It must be capable of representing the information that software transforms, the architecture and functions that enable the transformation to occur, the features that users desire, and the behavior of the system as the transformation is taking place.

In software engineering work, two classes of models can be created: requirements models and design models.

Requirements models also called analysis models representer customer requirements by depicting the software in three different domains:
* Functional domain
* Behavioral domain

Design models represent characteristics of the software that help practitioners to construct it effectively: 
* The architecture
* The user interface
* Component-level detail

| Principles                                                                                                                  | Description                                                                                                                                                                                       |
| --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The primary goal of the software team is to build software, not create models                                               | Models that slow the process down or provide little new insight should be avoided.                                                                                                                |
| Travel light— don't create more models than you need                                                                        | Create only those models that make it easier and faster to construct the software.                                                                                                                |
| Strive to produce the simplest model that will describe the problem or the software                                         | Simple models are easier for members of the software team to understand and critique                                                                                                              |
| Build models in a way that makes them amenable to change                                                                    | Assume that your models will change, but in making this assumption don't get sloppy.                                                                                                              |
| Be able to state an explicit purpose for each model that is created                                                         | Every time you create a model, ask yourself why you're doing so. If you can't provide solid justification for the existence of the model, don't spend time on it.                                 |
| Adapt the models you develop to the system at hand                                                                          | It may be necessary to adapt model notation or rules to the application. For example a video game application might require a different modeling technique than real-time.                        |
| Try to build useful models, but forget about building perfect models                                                        | Modeling should be conducted with an eye to the next software engineering steps. Iterating endlessly to make a model perfect does not serve the need for the agility                              |
| Don't become dogmatic about the syntax of the model. If it communicates content successfully, representation is secondary   | The most important characteristic of the model is to communicate information that enables the next software engineering task. If a model does this successfully, incorrect syntax can be forgiven |
| If your instincts tell you a model isn't right even though it seems okay on paper, you probable have reason to be concerned | If something tells you that a design model is doomed to fail, you have reason to spend additional time examining the model or developing a different one.                                         |
| Get feedback as soon as you can                                                                                             | Every model should be reviewed by member of the software team. The intent of these reviews is to provide feedback that can be used to correct modeling mistakes.                                  |
#### Requirements Modeling Principles

| Principle                                                                                                                                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| The infromation domain of a problem must be represented and understood                                                                                | The information domain encompasses the data that flow into the system, the data that flow out of the system and the data stores that collect and organize persistent data objects                                                                                                                                                                                                                                                                                                                            |
| The functions that the software performs must be defined                                                                                              | Software functions provide direct benefit to end users and also provide internal support for those features that are user visible. Some functions transform data that flow into the system. In other cases, functions effect some level of control over internal software processing or external system elements. Functions can be described at many different levels of abstraction, ranging from a general statement of purpose to a detailed description of the processing elements that must be invoked. |
| The behavior of the software (as a consequence of external events) must be represented                                                                | Input provided by end users, control data provided by an external system, or monitoring data collected over a network all cause the software to behave in a specific way.                                                                                                                                                                                                                                                                                                                                    |
| The models that depict information, function and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion | A large, complex problem is divided into subproblems until each subproblem is relatively easy to understand. This concept is called partitioning or separation of concerns and it is a key strategy in requirements modeling.                                                                                                                                                                                                                                                                                |
| The analysis task should move from essential information toward implementation detail                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
#### Design Modeling Principles

The software design is the equivalent of an architect's plan for a house. The design model that is created for software provides a variety of different views of the system. Some methods are data driven allowing the data structure to dictate the program architecture and the resultant processing components. Others are pattern driven, using information about the problema domain (the requirements model) to develop architectural styles and processing patterns. Still others are object oriented, using problem domain objects as the driver for the creation of data structure and the methods that manipulate them.

| Principles                                                                                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Design should be traceable to the requirements model                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Always consider the architecture of the system to be built                                                               | Software architecture is the skeleton of the system to be built. It affects interfaces, data structures, program control flow and behavior, the manner in which testing can be conducted, the maintainability of the resultant system and much more. For all those reasons design should start with architectural considerations. Only after the architecture has been established should component-level issues be considered. |
| Design of data is a important as design of processing functions                                                          | A well structured data design helps to simplify program flow, makes the design and implementation of software components easier, and makes overall processing more efficient                                                                                                                                                                                                                                                    |
| Interfaces (both internal and external) must be designed with care                                                       | A well-designed interface makes integration easier and assists the tester in validating component functions.                                                                                                                                                                                                                                                                                                                    |
| User interface design should be tuned to the needs of the end user. However, in every case it should stress ease of use. | A poor interface design often leads to the perception that the software is "bad"                                                                                                                                                                                                                                                                                                                                                |
| Component-level design should be functionally independent                                                                | Functional independence is a measure of the single mindedness of a software component. The functionality that is delivery by a component should be cohesive—that is, it should focus on one and only one function or sub function                                                                                                                                                                                               |
| Components should be loosely coupled to one another and to the external environment                                      | Coupling is achieved in many ways—via a component interface, by messaging, through global data. As the level of coupling increases, the likelihood of error propagation also increases and the overall maintainability of the software decreases                                                                                                                                                                                |
| Design representations (models) should be easily understandable                                                          | If the desing is difficult to understand, it will not serve as an effective communication medium.                                                                                                                                                                                                                                                                                                                               |
| The design should be developed iteratively                                                                               | With each iteration, the designer should strive for greater simplicity. The first iterations work to refine the design and correct errors, but later iterations should strive to make the design as simple as is possible.                                                                                                                                                                                                      |
| Creation of a design model does not preclude an agile approach                                                           | The purpose of a design model is to help others who must maintain and evolve the system. IT is extremely difficult to understand either the higher level purpose of a code fragment or its interactions with other modules in a modern multithreaded run-time environment.                                                                                                                                                      |
#### Living Modeling Principles

Living models support cooperation among all project stakeholders by providing appropriate model-based abstractions that describe interdependencies among system elements.

| Principles                                                                          | Description                                                                                                                                                                                                                                                                                                                                                           |
| ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Stakeholders-centric models should target specific stakeholders and their tasks     | This means that stakeholders are allowed to operate on the models at a level of abstraction that is appropriate, and that lower levers are hidden from them.                                                                                                                                                                                                          |
| Models and code should be closely coupled                                           | Any model that does not reflect the operable system is useless.                                                                                                                                                                                                                                                                                                       |
| Bidirectional information flow should be established between models and code        | Changes within the model, code and operable system must be allowed to propagate when they occur                                                                                                                                                                                                                                                                       |
| A common system view should be created                                              | A system meta model defines business processes and information objects in the IT management layer, running services and physical nodes in the system operations layer, and a requirements view in the software engineering layer. The associations in the system meta model describe dependencies from business process and business objects to the technology layer. |
| The information in the model must be persistent to allow tracking of system changes | The system model describes the current state of the system at all levels of abstraction. System evolution may be described and document as a sequence of system model snapshots.                                                                                                                                                                                      |
| Information consistency across all levels of the model must be verified             | Model constraint checking and state information retrieval are two important services required to support stakeholder decision making.                                                                                                                                                                                                                                 |
| Each model element has assigned stakeholder rights and responsibilities             | Each stakeholder is responsible for an identified subset of model elements. Each model subset is a stakeholder's domain. This means that each model element has access to information describing the actions each stakeholder is able to perform on the element.                                                                                                      |
| The states of various models elements should be represented                         | Just as the state of computation is defined by the values held by key variables during run time, the state of each model element can be defined by the values assigned to its attributes.                                                                                                                                                                             |
### Construction Principles

#### Coding Principles

The principles that guide the coding task are closely aligned with programming style, programming languages and programming methods.

##### Preparation Principles

Before you write one line of code, be sure you

| Principles                                                                                                                | Description |
| ------------------------------------------------------------------------------------------------------------------------- | ----------- |
| Understand of the problem you're trying to solve                                                                          |             |
| Understand basic design principles and concepts                                                                           |             |
| Pick a programming language that meets the needs of the software to be built and the environment in which it will operate |             |
| Select a programming environment that provides tools that will make your work easier                                      |             |
| Create set of unit test that will be applied once the component you code is completed                                     |             |
#####  Coding Principles

As you begin writing code, be sure you

| Principles                                                                             | Description |
| -------------------------------------------------------------------------------------- | ----------- |
| Constrain your algorithms by following structured programming practice                 |             |
| Consider the use of pair programming                                                   |             |
| Select data structures that will meet the needs of the design                          |             |
| Understand the software architecture and create interfaces that are consistent with it |             |
| Keep conditional logic as simple as possible                                           |             |
| Created nested loops in a way that makes them easily testable                          |             |
| Select meaningful variable names and follow other local coding standards               |             |
| Write code that is self-documenting                                                    |             |
| Create a visual layout (e.g. indentation and blank lines) that aids understanding      |             |

##### Validation Principles

After you've completed your first coding pass, be sure you

| Principles                                            | Description |
| ----------------------------------------------------- | ----------- |
| Conduct a code walkthrough when appropiate            |             |
| Perform unit test and correct errors you've uncovered |             |
| Refactor the code                                     |             |
##### Testing Principles

In a classic book on software testing states a number of rules that can serve ell as testing objectives (Glen Myers)

| Principles                                                                                       | Description                                                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Testing is a process of executing a program with the intent of finding an error                  |                                                                                                                                                                                                                               |
| A good test case is one that has a high probability of finding an as-yet undiscovered error      |                                                                                                                                                                                                                               |
| A successful test is one that uncovers an as-yet-undiscovered error.                             |                                                                                                                                                                                                                               |
| All test should be traceable to customer requirements                                            | The objective of software testing is to uncover errors. It follows that the most severe defects (from the customer's point view) are those that cause the program to fail to meet its requirements.                           |
| The Pareto Principle applies to software testing                                                 | The Pareto Principle implies that 80 percent of all errors uncovered during testing will likely be traceable to 20 percent of all program components.                                                                         |
| Testing should begin in the small and progress toward testing in the large                       | The first tests planned and executed generally focus on individual components. As testing progresses, focus shifts in an attempt to find errors in integrated clusters of components and ultimately in the entire system      |
| Exhaustive testing is not possible                                                               | It is impossible to execute every combination of paths during testing. It is possible, however, to adequately cover program logic and to ensure that all conditions in the component-level design have been exercised.        |
| Apply to each module in the system a testing effort commensurate with its expected fault density | These are often the newest modules or the ones that are least understood by the developers.                                                                                                                                   |
| Static testing techniques can yield high results                                                 | More than 85% of software defects originated in the software documentation.                                                                                                                                                   |
| Track defects and look for patterns in defects uncovered by testing                              | The total defects uncovered is a good indicator of software quality. The types of defects uncovered can be a good measure of software stability. Patterns of detects found over time can forecast numbers of expected defects |
| Include test cases that demonstrate software is behaving correctly                               | As a software components are being maintained or adapted, unexpected interactions cause unintended side effects in other components.                                                                                          |
Your objective is design test that systematically uncover different classes of errors and to do so with a minimum amount of time and effort. Testing cannot show the absence of errors and defects; it can show only that software errors and defects are present.

### Deployment Principles

A number of key principles should be followed as the team prepares to deliver an increment

| Principle                                                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                       |
| --------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Customer expectations for the software must be managed                | The starting point for managing expectations is to become more conscientious about what you communicate and how.                                                                                                                                                                                                                                                                                                                  |
| A complete delivery package should be assembled and tested            | All executable software, support data files, support documents and other relevant information should be assembled and thoroughly beta-tested with actual users.                                                                                                                                                                                                                                                                   |
| A support regime must be established before the software is delivered | An end user expects responsiveness and accurate information when a question or problem arises. If support is ad hoc, or worse, non-existent, the customer will become dissatisfied immediately. Support should be planned, support materiales should be prepared and appropriate record-keeping mechanims should be established so that the software team can conduct a categorical assessment of the kinds of support requested. |
| Appropriate instructional materiales must be provided to end users    | The software team delivers more than the software itself. Appropriate training aids should be developed: troubleshooting guidelines should be provided and when necessary a what's different about this software increment description should be published                                                                                                                                                                        |
| Buggy software should be fixed first, delivered later                 | Customers will forget you delivered a high-quality product a few days late, but they will never forget the problems that a low quality product caused them. The software reminds them every day.                                                                                                                                                                                                                                  |
### Agility Principles

| Principles                                                                                                                                  | Description |
| ------------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
| Our highest priority is to satisfy the customer through early and continuous delivery of valuable software                                  |             |
| Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage            |             |
| Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale               |             |
| Business people and developers must work together daily throughout the project                                                              |             |
| Build projects around motivated individuals. Give them the environment and support they need and trust them to get the job done             |             |
| The most efficient and effective method of conveying information to and within a development team is face-to-face conversations             |             |
| Working software is the primary measure of progress                                                                                         |             |
| Agile processes promote sustainable development. The sponsors, developers and users should be able to maintain a constant pace indefinitely |             |
| Continuous attention to technical excellence and good design enhances agility                                                               |             |
| Simplicity—the art of maximizing the amount of work not done— is essential                                                                  |             |
| The best architectures, requirements, and designs emerge from self-organizing teams                                                         |             |
| At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly                    |             |
# Software Engineering Phases

## Requirements

Identification and analysis of customer needs and system requirements. This includes documenting what the software should do.

- **Inception**: Initial phase where project scope and high-level objectives are discussed to identify key stakeholders and gather preliminary ideas.
- **Elicitation**: Engaging stakeholders through interviews, workshops, and surveys to gather detailed requirements and understand their needs.
- **Elaboration**: Refining gathered requirements to add detail, clarify ambiguities, and establish relationships between different requirements.
- **Negotiation**: Facilitating discussions among stakeholders to prioritize requirements, resolve conflicts, and reach agreements on essential features.
- **Specification**: Documenting requirements in a clear and formal manner, creating specifications that serve as a reference throughout development.
- **Validation**: Reviewing requirements with stakeholders to ensure they accurately reflect needs and can be realistically implemented in the project.
- **Management**: Ongoing process of tracking, updating, and controlling requirements to accommodate changes and ensure project alignment with stakeholder expectations.
### Establishing te groundwork

This phase involves laying the foundation for effective requirements gathering by engaging with stakeholders and understanding their diverse perspectives and needs. It sets the stage for a successful requirements management process.

| Activity                                  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Techniques                                                                                                                                                                       |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Identifying stakeholders                  | Determine who will be impacted by the software project, including end-users, clients, project sponsors, and technical teams. Understanding all relevant parties is crucial for gathering comprehensive requirements.                                                                                                                                                                                                                                                                                                                                                                                                                                                   | -Stakeholders analysis<br>-Stakeholder mapping<br>-Interviews<br>-Surveys<br>-Personas development                                                                               |
| Recognizing multiple viewpoints           | Acknowledge that different stakeholders may have varying priorities, concerns, and expectations. This diversity can provide valuable insights but may also lead to conflicting requirements that need to be managed.                                                                                                                                                                                                                                                                                                                                                                                                                                                   | -Focus groups<br>-Surveys<br>-Conflict resolution strategies<br>-Brainstorming sessions<br>-Affinity diagramming                                                                 |
| Working toward collaboration              | Foster a collaborative environment where stakeholders feel comfortable sharing their needs and perspectives. This can involve workshops, meetings, or collaborative tools to enhance communication and build consensus.                                                                                                                                                                                                                                                                                                                                                                                                                                                | -Collaborative workshops<br>-Brainstorming sessions<br>-Trello or Miro<br>-Design thinking sessions<br>-Regular check-ins                                                        |
| Asking the First Questions                | Initiate discussions by asking open-ended questions to explore stakeholders’ needs, goals, and challenges. This helps uncover underlying requirements and expectations early in the process:<br>1. Context-free questions focuses on the customer and other stakeholders, the overall project goals and benefits (measurable benefit of a successful implementation and possible alternatives to custom software development)<br>2. Questions to enable to gain a better understanding of the problem and allows the customer to voice his or her perceptions about a solution.<br>3. Questions that focuses on the effectiveness of the communication activity itself | -Five Whys technique<br>-User story mapping<br>-Feedback sessions<br>-Fishbone diagrams or root cause analysis<br>-Empathy mapping to understand user needs                      |
| Nonfunctional Requirements                | Identify and document nonfunctional requirements, such as performance, security, usability, and compliance. These aspects are critical to the overall success of the system and often affect user satisfaction.                                                                                                                                                                                                                                                                                                                                                                                                                                                        | -Checklists for common nonfunctional aspects<br>-Usability testing sessions<br>-Performance benchmarks<br>-Security assessments (e.g. threat modeling)<br>-Compliance checklists |
| Prioritize each nonfunctional requirement | Prioritize each nonfunctional requirement by creating a homogeneous set of nonfunctional requirements using a set of decision rules that establish which guidelines to implement and which to reject.                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | -Kano model<br>-MoSCoW method<br>-Weighted scoring model<br>-Cost-benefit analysis<br>-Impact-effort matrix<br>-Relationship matrix                                              |
| Traceability                              | Establish mechanisms for tracing requirements throughout the project lifecycle. This involves linking requirements to their sources and ensuring that changes can be tracked back to original stakeholder inputs, which helps maintain alignment and accountability.                                                                                                                                                                                                                                                                                                                                                                                                   | -Traceability matrix<br>-Tools like JIRA or Confluence<br>-Version Control System<br>-Requirement documentation audits<br>-Change management processes                           |
#### Collaborative Requirements Gathering

Many different approaches to collaborative requirements gathering have been proposed. Each makes use of a slightly different scenario, but all apply some variation on the following basic guidelines: 
* Meetings (either real or virtual) are conducted and attended by both software engineers and other stakeholders
* Rules for preparation and participation are established
* An agenda is suggested that is formal enough to cover all important points but informal enough to encourage the free flow of ideas
* A facilitator (can be a customer, a developer or an outsider) controls the meeting
* A definition mechanisms (can be work sheets, flip charts, or wall stickers or an electronic bulletin board, chat room, or virtual forum) is used.
The goal is to identify the problem, propose elements of the solution, negotiate different approaches and specify a preliminary set of solution requirements.

#### Quality Function Deployment

Quality Function Deployment (QFD) is a quality management technique that translates the needs of the customer into technical requirements for software. QFD emphasizes an understanding of what is valuable to the customer and then deploys these values throughout the engineering process.

1. **Identify Customer Requirements**: Gather and prioritize customer needs through surveys, interviews, or focus groups.
2. **Create the House of Quality**: This is a key tool in QFD, a matrix that relates customer requirements to technical specifications. The rows represent customer needs, and the columns represent technical features.
3. **Assess Relationships**: Use symbols or numbers in the matrix to indicate the strength of the relationship between customer needs and technical features.
4. **Prioritize Requirements**: Determine which customer needs are most critical and which technical features will best meet those needs.
5. **Develop Action Plans**: Based on the prioritized matrix, create actionable plans for the design and development teams.
6. **Continuous Improvement**: Review and update the QFD process as new customer feedback and requirements emerge.



### Elicitation Work Products

The work products produced as a consequence of requirements elicitation will vary depending on the size of the system or product to be built. For most systems the work products include:
1. A statement of need and feasibility
2. A bounded statement of scope for the system or product
3. A list of customers, users and other stakeholders who participated in requirements elicitation
4. A description of the system's technical environment
5. A list of requirements (preferably organized by function) and domain constraints that applies to each
6. A set of usage scenarios that provide insight into the use of the system or product under different operating conditions
7. Any prototypes developed to better define requirements
Additional:
1. Requirements Traceability Matrix that link requirements to their sources, ensuring that all needs are addressed.
2. Risk analysis to assess potential risks related to the requirements and their impact on the project.
3. Prioritization of requirements that have a ranking of requirements based on criteria such as business value, risk and urgency.
4. Glossary of terms with shared vocabulary to ensure all stakeholders understand specific terminology used in the requirements.
5. Stakeholder agreement where stakeholders confirming agree with the elicited requirements and scope
All of these work products is reviewed by all people who have participated in requirements elicitation.

Some artifacts can vary depending on the model process for example:

| Model process                       | Artefacts                                                                                                                                                                                                    |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Agile                               | -User stories                                                                                                                                                                                                |
| Service-Oriented methods            | -Service definitions                                                                                                                                                                                         |
| Waterfall                           | -Requirements Specification Documents (ERS)                                                                                                                                                                  |
| Extreme Programming                 | -Acceptance Test                                                                                                                                                                                             |
| Feature-Driven Development (FDD)    | -Feature List                                                                                                                                                                                                |
| Model-Driven Development (MDD)      | -Domain Models                                                                                                                                                                                               |
| Rapid Application Development (RAD) | -Prototypes                                                                                                                                                                                                  |
| ICONIX                              | -Use case Diagrams<br>-Use case Specifications                                                                                                                                                               |
| Incremental Development             | -Incremental Requirement List<br>-Requirements Backlog                                                                                                                                                       |
| Spiral Model                        | -Risk Analysis Documents<br>-Prototyping Feedback                                                                                                                                                            |
| V-Model                             | -Requirements Specifications<br>-Traceability Matrix                                                                                                                                                         |
| Behavior-Driven Development (BDD)   | -Feature Files<br>-Scenarios                                                                                                                                                                                 |
| DevOps                              | -Continuous Feedback Loops<br>-User Feedback Reports                                                                                                                                                         |
| Aspect-Based Development            | -Aspect Specifications<br>-Aspect Diagrams                                                                                                                                                                   |
| Component-Based Development         | -Component Catalog<br>-Interface Specificatios                                                                                                                                                               |
| Prototyping                         | -Prototypes (Low-fidelity and High-fidelity)<br>-Prototype Evaluation Reports<br>-User Feedback Documentation<br>-Requirement Refinement Documents<br>-User Interface Specifications<br>-User Case Scenarios |

### Common Errors

| Error                                | Description                                                                                                               |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| Lack of stakeholder involvement      | Not including all relevant stakeholders can lead to an incomplete understanding of requirements.                          |
| Poor communication                   | Using technical jargon or failing to communicate concepts clearly can create misunderstandings.                           |
| Not prioritizing requirements        | Treating all requirements as equally important can hinder decision-making and time management.                            |
| Assuming requirements                | Making assumptions about user needs without validating them can result in a product that fails to meet expectations.      |
| Inadequate documentation             | Failing to record requirements clearly and accessibly can cause confusion later on.                                       |
| Ignoring Non-Functional Requirements | Focusing solely on functional requirements while overlooking aspects like performance and security.                       |
| Uncontrolled changes                 | Not managing changes to requirements properly can lead to scope creep and timeline issues.                                |
| Lack of validation                   | Not reviewing and validating requirements with stakeholders can result in misunderstandings about what needs to be built. |
| Not testing prototypes               | Failing to use prototypes for early feedback and adjusting requirements accordingly.                                      |
| Narrow project vision                | Not considering the broader context of the system or product and how it will integrate into the user environment.         |

### Anti-patterns

| Anti-pattern                         | Description                                                                                                   |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| Gold plating                         | Adding unnecessary features that weren't requested, leading to scope creep and complexity.                    |
| Scope creep                          | Allowing requirements to expand without proper management, which can derail timelines and budgets.            |
| Overly detailed requirements         | Being too prescriptive can stifle creativity and flexibility in the design and implementation phases.         |
| Lack of user involvement             | Failing to engage end-users can result in missing critical insights about actual needs.                       |
| Assumption-Based requirements        | Relying on assumptions rather than gathering concrete information from stakeholders.                          |
| One-Size-Fits-All approach           | Applying the same requirements-gathering techniques to every project, ignoring context and unique needs.      |
| Ignoring Non-Functional Requirements | Focusing only on functional aspects and neglecting performance, security, and usability considerations.       |
| Inadequate documentation             | Failing to document requirements clearly can lead to misunderstandings and misalignment later in the project. |
| Failure to validate                  | Not reviewing requirements with stakeholders can lead to a disconnect between expectations and deliverables.  |
| Rigid process                        | Adhering strictly to a process without adapting it to the project's needs can lead to inefficiencies.         |

### Analysis Model

A broader representation that encompasses all analysis classes along with their relationships, use cases, and overall requirements. It provides a comprehensive view of the system's functionality and interactions.

The analysis model serves as a bridge between the requirements gathering and design stages, ensuring that the gathered requirements are accurately represented and serve as a foundation for detailed design work. This iterative refinement helps maintain alignment with user needs and technical considerations.

The intent of the analysis model is to provide a description of the required informational, functional and behavioral domains for a computer-based system. The model changes dynamically as you learn more about the system to be built, and other stakeholders understand more about what they really require. For that reason, the analysis model is a snapshot of requirements at any given time.

As the analysis model evolves, certain elements will become relatively stable, providing a solid foundation for the design task that follow. However, other elements of the model may be more volatile, indicating that stakeholders do not yet fully understand requirements for the system.

#### Analysis Classes

Represents specific entities or objects in the problem domain. It includes attributes and behaviors relevant to user requirements, focusing on what the system needs.

In system design, analysis classes are the initial step in understanding the problem domain and requirements of the software system. They focus on identifying and defining the key entities, attributes, and relationships within the system without delving into implementation details.

- Analysis classes serve as the investigators or detectives of the system design process.
- They gather information about what the system needs to accomplish, who will use it, and what data it will handle.
- This involves studying user needs, business processes, and any external systems the software will interact with.
- Analysis classes help developers gain a clear understanding of the problem domain and the goals of the software.

Overall, analysis classes are essential for ensuring that the software solution aligns with the needs of its users and stakeholders.

##### Characteristics Analysis Classes

- Focus on understanding the problem domain and requirements.
- Abstract representation of entities, attributes, and relationships.
- High-level view without delving into implementation details.
- Identify user needs, business processes, and external system interactions.
- Typically depicted through domain models, use cases, or user stories.

##### Usage Analysis Classes

- Serve as the initial step in system design to gather and analyze requirements.
- Facilitate communication between stakeholders to ensure a shared understanding of the system.
- Provide a foundation for further design and development phases.
- Help identify key functionalities and constraints of the system.
- Used to create user stories, use cases, and domain models to capture requirements.

##### Analysis Rules of Thumb

* The model should focus on requirements that are visible within the problem or business domain. The level of abstraction should be relative high. "Don't get bogged down in details" that try to explain how the system will work.
* Each element of the requirements model should add to an overall understanding of software requirements and provide insight into the information domain, function and behavior of the system.
* Delay consideration of infrastructure and other nonfunctional models until design. That is, a database may be required, but the classes necessary to implement it, the functions required to access it, and the behavior that will be exhibited as it is used should be considered only after problem domain analysis has been completed.
* Minimize coupling throughout the system. It is important to represent relationships between classes and functions. However, if the level of "inter-connectedness" is extremely high, efforts should be made to reduce it.
* Be certain that the requirements model provides value to all stakeholders. Each constituency has its own use for the model. For example, business stakeholders should use the model to validate requirements, designers should use the model as a basis for design: QA people should use the model to help plan acceptance tests.
* Keep the model as simple as it can be. Don't add additional diagrams when they add no new information. Don't use complex notational forms when a simple list will do.

The degree to which requirements for Web and mobile apps is emphasized depends on the following size-related features:
1. The size and complexity of the application increment
2. The number of stakeholders (analysis can help to identify conflicting requirements coming from different sources)
3. The size of the app development team
4. The degree to which members of the team have worked together before (analysis can help develop a common understanding of the project)
5. The degree to which the organization's success is directly dependent on the success of the application


#### Elements of the Analysis Model

There are many different ways to look at the requirements for a computer-based system. Different modes of representation force you to consider requirements from different viewpoints—an approach that has a higher probability of uncovering omissions, inconsistencies, and ambiguity. A set of generic elements is common to most analysis models:
* Scenario-based elements: The system is described f rom the user's point of view using a scenario-based approach.
* Class-based elements: Each usage scenario implies a set of objects that are manipulated as an actor interacts with the system
* Behavioral elements: The behavior of a computer-based system can have a profound effect on the design that is chosen and the implementation approach that is applied. Therefore, the requirements model must provide modeling elements that depict behavior.

Together, these elements provide a comprehensive view of the system's requirements, ensuring clarity and thoroughness in understanding how users will interact with the system, what data will be managed, and how the system will behave in different scenarios. This multifaceted approach increases the likelihood of uncovering any omissions or inconsistencies in the requirements.

In Agile Requirements Engineering the intent is to transfer ideas from stakeholders to the software team rather than create extensive analysis work products. Agile requirements engineering addresses important issues that are common in software projects: high requirements volatility, incomplete knowledge of development technology, and customers not able to articulare their visions until they see a working prototype

In self-adaptive systems can reconfigure themselves, augment their functionality, protect themselves, recover from failure, and accomplish all of this while hiding most of their internal complexity from their users. Adaptive requirements document the variability needed for self-adaptive systems.


![](images/Pasted%20image%2020241005081650.png)
##### Scenario-based models

This approach describes the system from the user's perspective, focusing on specific interactions between users (actors) and the system.

It helps to illustrate how users will engage with the system in various contexts, allowing for a better understanding of functional requirements. Scenarios can reveal user goals, workflows, and potential challenges.

| Model              | Purpose                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Example                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Use case diagrams  | Visualize user interactions with the system, outlining functional requirements.<br><br>Use early in the requirements gathering phase to capture high-level functionalities and identify stakeholders.                                                                                                                                                                                                                                                                                                                       | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928164930.png?raw=true" width="200">                                                                                                                                                                                                                                                                                        |
| User stories       | Describe features from the end-user perspective in a simple, informal way. <br><br>Use in agile methodologies, during sprint planning, to prioritize and understand user needs.                                                                                                                                                                                                                                                                                                                                               | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165004.png?raw=true" width="200">                                                                                                                                                                                                                                                                                        |
| Activity diagram   | Illustrate workflows and the sequence of actions in a process.<br><br>Use when analyzing business processes or detailing user workflows.                                                                                                                                                                                                                                                                                                                              | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240930152907.png?raw=true" width="200" height="200">                                                                                                                                                                                                                                                                                        |
| Swimlane diagrams  | Organize activities into lanes that represent different actors or departments, illustrating responsibilities within a process.<br><br>Use when clarifying roles and interactions in complex workflows.                                                                                                                                                                                                                                                                                                                           | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240930152846.png" width="200">                                                                                                                                                                                                                                                                                        |
| Sequence diagram   | Show the order of interaction between objects over time.<br><br>Use when detailing specific interactions and their timing in a use case.                                                                                                                                                                                                                                                                                                                                | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165156.png?raw=true" width="200">                                                                                                                                                                                                                                                                                        |
| Deployment         | Illustrate the physical arrangement of hardware and software components in a system, showing how artifacts (like applications and services) are distributed across nodes (e.g., servers, devices).<br><br>Use:<br>- When designing the deployment architecture of a system.<br>- To visualize how software will be distributed across different hardware environments.<br>- During discussions about scalability, performance, and resource allocation.<br>- For documenting the configuration of systems in operational settings. | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020241001221816.png?raw=true" width="200">    

##### Class-based models

This aspect identifies the objects or classes that the system will manage, based on the usage scenarios. Each class represents a distinct entity within the system.

Class-based elements help to define the data structure and relationships between objects. This is crucial for understanding how different components interact and ensuring that the system can accurately model real-world entities and their behaviors.


| Model                                   | Purpose                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Example                                   |
| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| Class diagrams                          | Define the structure of the system by showing classes, attributes, methods and relationships.<br><br>Use after gathering requirements, during the design phase, to establish the data model.                                                                                                                                                     | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165228.png?raw=true" width="200"> |
| Object diagrams                         | Show instances of classes and their relationships at a specific moment.<br><br>Use to clarify the state of a system at a particular time, especially during discussions of object interactions.                                                                                                                                                                                                                                                                                  | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165251.png?raw=true" width="200"> |
| Entity-Relationship diagrams            | Visualize the dat model, focusing on entities and their relationships. <br><br>Use when designing the database schema or analyzing data requirements.                                                                                                                                                                                                                                                                                                                            | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165333.png?raw=true" width="200"> |
| Component diagrams                      | Show how components interact and their relationships<br><br>Use during system architecture discussions to understand modular structures.                                                                                                                                                                                                                                                                                                                                         | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165541.png?raw=true" width="200"> |
| Class-Responsibility-Collaborator model | It helps in identifying classes in a system and clarifying their responsibilities and collaborations with other classes.<br><br>Use when need to clarify and structure of your design process.<br><br>                                                                                                                                                                                                                                                                           | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928224348.png?raw=true" width="200"> |
| Package diagrams                        | Shows how different packages (groups of related classes) are organized within a system and how they interact with one another. <br><br>Use:<br>- When designing a system architecture to provide a clear overview of the structure.<br>- During the analysis phase to identify potential dependencies and organization of classes.<br>- For documenting existing systems to aid in maintenance and future development.<br>                                                       | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020241001222121.png?raw=true" width="200"> |
| Composite structure                     | Describes inner structure of component including all classes, interfaces of the component, etc.<br><br>Use:<br>- When you need to detail the internal structure of a class or component.<br>- To illustrate how different parts of a system interact and collaborate.<br>- During the design phase to clarify relationships between classes and their parts.<br>- To document complex systems where components need to be visualized in relation to their containing structures. | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020241001221735.png?raw=true" width="200"> |

##### Behavioral-based and patterns-based models

These elements focus on the dynamic behavior of the system, describing how objects interact and change state in response to events or actions.

By modeling behaviors, you can identify the system’s response to various inputs and events, ensuring that it meets user expectations. This includes defining state transitions, methods, and the overall lifecycle of objects within the system.


| Model                  | Purpose                                                                                                                                                                     | Example                                   |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| State machine diagrams | Describe the states of an object and transitions between states based on events.<br><br>Use when modeling complex behaviors of individual objects, such as order processing | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165635.png?raw=true" width="200"> |
| Sequence diagrams      | Show object interactions in a time sequence.<br><br>Use in a detailed design discussions where timing and order of events matter.                                           | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165711.png?raw=true" width="200"> |
| Collaboration diagrams | Focus on the relationships between objects and how they collaborate to fulfill a use case.<br><br>Use to emphasize the structural organization of the system during design. | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165734.png?raw=true" width="200"> |
| Activity diagrams      | Detail workflows and parallel processes.<br><br>Use to model complex workflows, especially when multiple activities occur simultaneously                                    | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928165922.png?raw=true" width="200"> |


##### Data models

A data model is a conceptual framework that defines how data is organized, stored, and manipulated within a system. It includes the structure of data elements, their relationships, and the constraints governing the data.

| Data model            | Description                                                                                                                                  | Example                                   |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| Conceptual data model | A high-level representation that outlines the key entities and their relationships without delving into implementation details.<br><br><br>  | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928204356.png?raw=true" width="300"> |
| Logical data model    | A detailed representation that defines data elements and their relationships in a way that is independent of specific database technologies. | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928204615.png?raw=true" width="300"> |
| Physical data model   | Specific how data will be physically stored in a database, including table structures, data types, and indexing.                             | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928204553.png?raw=true"  width="300"> |




![](images/Pasted%20image%2020240928204253.png)


##### Flow-oriented models

Focus on the flow of data and control within a system, emphasizing how information moves through various processes and components. They are often used in system design to represent the dynamics of processes and the interactions between them. The key characteristics are:
- **Data Flow Representation**: They illustrate how data enters, moves through, and exits various processes in a system.
- **Processes and Functions**: Emphasize the functions or processes that transform data and the relationships between those processes.
- **Control Flow**: Indicate the sequence in which processes occur, often using arrows to show the direction of data movement.

| Data model              | Description                                                                                                                                                                                                                                                                                                                                                    | Example                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| Data Flow Diagram (DFD) | Visually represent how data flows within a system, illustrating processes, data stores, external entities, and data movement.<br><br>-Use to map out processes and data interactions.<br>-Use to identify how information is processed and where data is stored.<br>-Use when communicating system functionality to stakeholders who may not be technical.<br> | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928211343.png?raw=true" width="200"> |
| Flowcharts              | Provide a step-by-step diagram of a process, using standardized symbols to represent actions, decisions, inputs, and outputs. They show the flow of control and data through various stages of a process.                                                                                                                                                      | <img src="https://github.com/adrianc68/software-engineering-concepts/blob/main/images/Pasted%20image%2020240928211549.png?raw=true" width="200"> |



#### Analysis Patterns

**Analysis patterns** are reusable solutions or templates for common problems encountered during the analysis and design phases of software development. They capture best practices and proven approaches to specific challenges, helping to streamline the development process. The purpose of Analysis Patterns are:
- **Efficiency**: They reduce the time and effort required to solve recurring problems by providing pre-defined solutions.
- **Consistency**: Promote uniformity in design decisions, leading to more coherent and maintainable systems.
- **Communication**: Serve as a common language among developers, analysts, and stakeholders, facilitating better understanding and collaboration.
- **Quality**: Enhance the quality of the final product by leveraging established solutions that have been tested and validated.

How to use:
1. **Identify Common Problems**: Recognize scenarios in your project that align with known patterns, such as data management, user interactions, or system integrations.
2. **Select Appropriate Patterns**: Choose patterns that best fit the identified problems. Patterns can vary by context, so consider specific requirements and constraints.
3. **Adapt Patterns**: Customize the chosen patterns to suit your specific project needs. This may involve adjusting parameters or integrating with other components.
4. **Document Usage**: Clearly document how the patterns are applied within your system design to ensure that all team members understand the rationale and implementation.
5. **Review and Iterate**: Evaluate the effectiveness of the patterns in practice, and be open to refining or modifying them based on project outcomes and feedback.

Examples:
- **Repository Pattern**: Used for managing data access, encapsulating data retrieval and storage logic to provide a cleaner interface for data operations.
- **Event Sourcing Pattern**: Captures state changes as a sequence of events, useful in systems requiring audit trails or versioned data.
- **Domain Model Pattern**: Represents business logic and rules, encapsulating the state and behavior of domain objects.

#### Validating Requirements

As each element of the requirements model is created, it is examined for inconsistency, omissions and ambiguity. The requirements represented by the model are prioritized by stakeholders and grouped within requirements packages that will be implemented as software increments. A review of the requirements model addresses the following questions:

1. Is each requirement consistent with the overall objectives for the system or product?
2. Have all requirements been specified at the proper level of abstraction? That is, do some requirements provide a level of technical detail that is inappropriate at this stage?
3. Is the requirement really necessary or does it represent an add-on feature that may no be essential to the objective of the system?
4. Is each requirement bounded and unambiguous?
5. Does each requirement have attribution? That is, is a source (generally a specific individual) noted for each requirement?
6. Do any requirements conflict with other requirements?
7. Is each requirement achievable in the technical environment that will house the system or product?
8. Is each requirement testable, once implemented?
9. Does the requirements model properly reflect the information, function and behavior of the system to be build?
10. Has the requirements model been "partitioned" in a way that exposes progressively more detailed information about the system?
11. Have requirements pattern been used to simplify the requirements model? Have all patterns been properly validated? Are all patterns consistent with customer requirements?


### Requirements Modeling

At a technical level, software engineering begins with a series of modeling tasks that lead to a specification of requirements and a design representation for the software to be built. The requirements model—actually a set of models—is the first technical representation of a system.

Requirements modeling uses a combination of text and diagrammatic forms to depict requirements in a way that is relatively easy to understand, and more important, straightforward to review for correctness, completeness and consistency.

It is important to validate software requirements, you need to examine them from a number of different points of view.

The objective is to create a variety of representations that describe what the customer requires, establish a basis for the creation of a software design, and define a set of requirements that can be validated once the software is built. The requirements models bridges the gap between a system-level description that describes overall system and business functionality and a software design that describes the software's application architecture, user interface and component-level structure.

#### Approaches

One view of requirements modeling, called structured analysis, considers data and the processes that transform the data as separate entities. Data objects are modeled in a way that defines their attributes and relationships. Processes that manipulate data objects are modeled in a manner that shows how they transform data as data objects flow through the system.

A second approach to analysis modeling, called object-oriented analysis, focuses on the definition of classes and the manner in which they collaborate with one another to effect customer requirements. 

Each element of the requirements model presents the problem from a different point of view. Scenario-based elements depict how the user interacts with the system and the specific sequence of activities that occur as the software is used. Class-based elements model the objects that the system will manipulate, the operations that will be applied to the objects to effect the manipulation, relationships (some hierarchical) between the objects, and. the collaboration that occur between the classes that are defined. Behavioral elements depict how external events change the state of the system or the classes that reside within it. Finally, flow-oriented elements represent the system as an information transform, depicting how data objects are transformed as they flow through various system functions.

Analysis modeling leads to the derivation of one or more of these modeling elements. However, the specific content of each element (i.e., the diagrams that are used to construct the element and the model) may differ from project to project. Only those modeling elements that add value to the model should be used.

![](images/Pasted%20image%2020240929012312.png)

#### Requirements Analysis

This results in the specification of software's operational characteristics, indicates software's interface with other system elements, and establishes constraints that software must need. Requirement analysis allows you (regardless of whether you're called a software engineer, an analyst or a modeler) to elaborate on basic requirements established during the inception, elicitation, and negotiation tasks that are part of requirements engineering. The requirements modeling action results in one or more of the following type of models:
* Scenario-based models of requirements from the point of view of various system "actors"
* Class-oriented models that represent object-oriented classes (attributes and operations) and the manner in which classes collaborate to achieve system requirements.
* Behavioral and patterns-based models that depict how the software behaves as a consequence of external "events"
* Data models that depict the information domain for the problem
* Flow-oriented models that represent the functional elements of the system and how they transform data as they move through the system
These models provide a software designer with information that can be translated to architectural, interface, and component-level designs. Finally, the requirements model (and the software requirements specification) provides the developer and the customer with the means to assess quality once software is built
##### Scenario-Based Modeling

This represents the system from the user's point of view. By building a scenario-base model, you will be able to better understand how the user interacts with the software, uncovering the major functions and features that stakeholder require of the system.

Scenario-based modeling produces a text-oriented representation call a "use case". The use case describes a specific interaction in a manner that can be informal (a simple narrative) or more structured and formal in nature. The use case can be supplemented with a number of different UML diagrams that overlay a more procedural view of the interaction.

Your primary focus is on what, not how. What user interaction occurs in a particular circumstance, what objects does the system manipulate, what functions must the system perform, what behaviors does the system exhibit, what interfaces are defined and what constraints apply?

The requirements model must achieve three primary objectives:
1. To describe what the customer requires
2. To establish a basis for the creation of a software design
3. To define a set of requirements that can be validated once the software is built 

It is important to note that all elements of the requirements model will be directly traceable to parts of the design model. A clear division of analysis and design tasks between these two important modeling activities is not always posible. Some design invariably occurs as part of analysis and some analysis will be conducted during design.

#### Class-based Modeling

Also categorized as object-oriented analysis. Object-oriented methods are based upon concepts that we first learned in kindergarten objects and attributes, wholes and parts, class and members.

Class-based methods for requirements modeling use these common concepts to craft a representation of an application that can be understood by nontechnical stakeholders. 

Class-based modeling represents the objets that system will manipulate, the operations (also called methods or services) that will be applied to the objects to effect the manipulation, relationships (some hierarchical) between the objects, and the collaboration that occur between the classes that are defined. Each object becomes a member of a class of objects. Each object is descried by its state—the data attributes that describe the object. All of this can be represented using class-based requirements modeling methods.

A class-based requirements models makes use of objects drawn from the customer's view of an application or system. The model depicts a view of the system that is common to the customer. Later, as the model is refined, it becomes the basis for software design.

Class-based modeling defines objects, attributes, and relationships. A set of simple heuristics can be developed to extract objects and classes from a problem statement and then represent them in text-based and/or diagrammatic forms. Once preliminary models are created, they are refined and analyzed to assess their clarify, completeness and consistency.

The work product is a wide array of text-based and diagrammatic forms may be chosen for the requirements model. Each of these representations provides a view of one or more of the models elements.

#### Behavior modeling

For some types of software, the use case may be the only requirements modeling representation that is required. For others, an object-oriented approach is chosen and class-based models may be developed.  But in other situations, complex application requirements may demand an examination of how an applications behaves as a consequence of external events; whether existing domain knowledge can be adapted to the current problem; or in the case of Web-based or mobile system and applications, how content and functionality meld to provide an end user with the ability to successfully navigate an application to achieve usage goals.

It is important because you may not have the time, the resources or the inclination to develop every representation, recognize that each different modeling approach provides you with a different way of looking of the problem.

Behavioral modeling depicts the states of the system and its classes and the impact of events on these states. Pattern-based modeling makes use of existing domain knowledge to facilitate requirements analysis. WebApp requirements models are especially adapted for the representation of content, interaction, function and configuration-related requirements

A wide array of text-baed and diagrammatic forms may be chosen for the requirements model. Each of these representations provides a view of one or more of the model elements

The behavioral model indicates how software will respond to external events or stimuli. To create the model you should perform the following steps:
1. Evaluate all use cases to fully understand the sequence of interaction within the system
2. Identify events that drive the interaction sequence and understand how these events relate to specific objects
3. Create a sequence for each use case
4. Build a state diagram for the system
5. Review the behavioral model to verify accuracy and consistency
An event is not the information that has been exchanged, but rather the fact that information has been exchanged.

In the context of behavioral modeling, two different characterizations of states must be considered:
1. The state of each class as the system performs its function
2. The state of the system as observed from the outside as the system performs its function

#### Requirements Modeling Output

Requirement analysis provides a disciplined mechanism for representing and evaluating application content and function, the modes of interaction that users will encounter, and the environment and infrastructure in which the WebApp or mobile app resides.

Each of these characteristics can be represented as a set of models that allow application requirements to be analyzed in a structured manner. While the specific models depend largely upon the nature of the application, there are five main classes of models:
* **Content model**: identifies the full spectrum of content to be provided by the application. Content includes text, graphics and images, video, and audio data.
* **Interaction model:** describes the manner in which users interact with the app.
* **Functional model**: defines the operations that will be applied to manipulate content and describes other processing functions that are independent of content but necessary to the end user.
* **Navigation model**: defines the overall navigation strategy for the app
* **Configuration model**: describes the environment and infrastructure in which the app resides.

You can develop each of these models using a representation scheme (often called a "language") that allows its intent and structure to be communicated and evaluated easily among members of the engineering team and other stakeholders. As a consequence a list of key issues (e.g. errores, omissions, inconsistencies, suggestions for enhancement or modification, points of clarification) are identified and acted upon.

### Domain Analysis 

Analysis pattern often reoccur across many applications within a specific business domain. If these patterns are defined and categorized in a manner that allows you to recognize and apply them to solve common problems, the creation of the analysis model is expedited. More important, the likelihood of applying design patterns and executable software components grows dramatically. This improves time-to-market and reduces development costs. But how are analysis patterns and classes recognized in the first place? Who defines them, categorizes them and readies them for use on subsequent projects? The answers to these questions lie in domains analysis.

Software domain analysis is the identification analysis and specification of common requirements from a specific application domain, typically for reuse on multiple projects within that application domain... \[Object-oriented domain analysis is\] the identification analysis and specification of common, reusable capabilities within a specific application domain in terms of common objects, classes, subassemblies and frameworks.

The goal of domain analysis is straightforward: to find or create those analysis classes and/or analysis patterns that are broadly applicable so that they may be reused. The role of the domain analyst is to discover and define analysis patterns, analysis classes, and related information that may be used by many people working on similar but no necessarily the same applications.

![](images/Pasted%20image%2020240929010351.png)



# Designs

Creating an architecture and detailed design of the software. Here, the structure of the system, interfaces, and components are defined.

Software design encompasses the set of principles, concepts and practices that lead to the development of a high-quality system or product. Design creates a representation or model of the software, but unlike the requirements model (that focuses on describing required data, function and behavior), the design model provides detail about software architecture, data structures, interfaces, and components that are necessary to implement the system.

Design allows you to model the system or product that is to be built. This model can be assessed for quality and improved before code is generated, test are conducted, and end users become involved in large numbers. Design is the place where software quality is established. 


Steps:
1. The architecture of the system or product must be presented
2. The interfaces that connect the software to end users, to other systems and devices, and to its own constituent components are modeled
3. The software components that are used to construct the system are designed.
Each of these views represents a different design action, but all must conform to a set of basic design concepts that guide software design work.

The work product is a design model that encompasses architectural, interface, component-level, and deployment representations is the primary work product that is produced during software design

The goal of design is to produce a model or representation that exhibits firmness (A program should not have any bugs tat inhibit its function), commodity (a program should be suitable for the purpose for which it was intended) and delight (the experience of using the program should be a pleasurable one).

Beginning once software requirements have been analyzed and modeled, software design is the last software engineering action within the modeling activity and sets the stage for **construction**.

![](images/Pasted%20image%2020240929210435.png)

The data/class design transforms class models into design class realizations and the requisite data structures required to implement the software. The objects and relationship defined in the CRC diagram and the detailed data content depicted by class attributes and other notation provide the basis for the data design activity. Part of class design may occur in conjunction with the design of the software architecture.

* The architectural design defines the relationship between major structural elements of the software, the architectural styles and patterns. The architectural design representation—the framework of a computer-based system—is derived from the requirements model.

* The interface design describes how the software communicates with system that interoperate with it, and with humans who use it. An interface implies a flow of information (e.g. data and/or control) and a specific type of behavior. Therefore, usage scenarios and behavioral models provide much of the information required for interface design.

* The component-level design transforms structural elements of the software architecture into a procedural description of software components. Information obtained from the class-based models and behavioral models serve as the basis for component design.

Design is the place where quality is fostered in software engineering. Design provides you with representations of software that can be assessed for quality. Design os the only way that you can accurately translate stakeholder's requirements into a finished software or system.

Software design servers as the foundation for all the software engineering and software support activities that follow. Without design, you risk building an unstable system—one that will fail when small changes are made; one that may be difficult to test; one whose quality cannot be assessed until late in the software process, when time is short and many dollars have already been spent.

## Software Quality Guidelines and Attributes

Three characteristics that serve as guide for evaluation of a good design:
1. The design should implement all of the explicit requirements contained in the requirements model, and it must accommodate all of the implicit requirements desired by stakeholders
2. The design should be a readable, understandable guide for those who generate code and for those who test and subsequently support the software
3. The design should provide a complete picture of the software, addressing the data, functional, and behavioral domains from an implementation perspective
To achieve these goal the software team must establish technical criteria for good design. For the time being, consider the following guidelines:

Quality guidelines:
1. A design should exhibit an architecture that (1) has been created using recognizable architectural styles or patterns, (2) is composed of components that exhibit good design characteristics and (3) can be implemented in a evolutionary fashion thereby facilitating implementation and testing.
2. A design should be modular: that is, the software should be logically partitioned into elements or subsystems
3. A design should contain distinct representations of data, architecture, interfaces and components
4. A design should lead to data structures that are appropriate for the classes to be implemented and are drawn for recognizable data
5. A design should lead to components that exhibit independent functional characteristics
6. A design should lead to interfaces that reduce the complexity of connections between components and with the external environment
7. A design should be derived using a repeatable method that is driven by information obtained during software requirements analysis
8. A design should be represented using a notation that effectively communicates its meaning.
Quality attributes: The FURPS (functionality, usability, reliability, performance and supportability) represent a target for all software design:
1. Functionality: is assessed by evaluating the feature set and capabilities of the program, the generality of the functions that are delivered and the security of the overall system.
2. Usability: is assessed by considering human factors, overall aesthetics, consistency and documentation.
3. Reliability: is evaluated by measuring the frequency and severity of failure, the accuracy of output results, the mean-time-to-failure (MTTF), the ability to recover from failure, and the predictability of the program.
4. Performance: is measured using processing speed, response time, resource consumption, throughput and efficiency.
5. Supportability: combines extensibility, adaptability and serviceability. These three attributes represente a more common term, maintainability.
Not every software quality attribute is weighted equality as the software design is developed. 
## Software Design Methods

Each software design method introduces unique heuristics and notation, as well as a somewhat parochial view of what characterizes design quality. All the methods have a number of common characteristics:
1. A mechanism for the translation of the requirements model into a design representation
2. A notation for representing functional components and their interfaces
3. Heuristics for refinement and partitioning
4. Guidelines for quality assessment

| Method                              | Description                                                                                                                                                                                                                                                                                                                                                                                                        |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Structured Design                   | This method focuses on the functional decomposition of the system. It uses flowcharts and structured diagrams to represent functionality and interactions between modules. It is ideal for systems with well-defined requirements.                                                                                                                                                                                 |
| Object-Oriented Design (OOD)        | OOD is based on encapsulating data and behaviors within objects. It employs notations like UML (Unified Modeling Language) to represent classes, objects, and their interactions. It promotes code reuse and extensibility.                                                                                                                                                                                        |
| Component-Based Design              | This approach emphasizes the development of reusable components that can be assembled to form applications. Each component has well-defined interfaces, facilitating integration and maintenance.                                                                                                                                                                                                                  |
| Service-Oriented Architecture (SOA) | SOA organizes software as a set of services that communicate with each other through well-defined interfaces. This method is useful for distributed systems and allows interoperability between different platforms.                                                                                                                                                                                               |
| Agile Design                        | This method emphasizes flexibility and continuous collaboration with stakeholders. It uses short development cycles (sprints) to iterate on the design and allows for rapid adjustments based on client feedback.                                                                                                                                                                                                  |
| Model-Driven Design                 | In this approach, abstract models are used to automatically generate parts of the code. It allows for separation of concerns and improves consistency, making it easier to adapt to changes in requirements.                                                                                                                                                                                                       |
| Domain-Driven Design (DDD)          | DDD focuses on creating a model that reflects the problem domain. It promotes collaboration between domain experts and developers to create a design that captures the language and rules of the business.                                                                                                                                                                                                         |
| Aspect-Oriented Design (AOD)        | This method focuses on separating cross-cutting concerns—such as logging, security, and error handling—from the core business logic. AOD uses aspects to encapsulate these concerns, allowing for better modularity and easier maintenance. This approach helps to reduce code duplication and improves the separation of responsibilities.                                                                        |
| Test-Driven design (TDD)            | TDD is a methodology where tests are written before the actual code is developed. It follows a cycle of writing a test, writing the minimum code to pass the test, and then refactoring. This ensures that the design is driven by the requirements and helps to create a robust and reliable codebase. TDD encourages continuous integration and frequent feedback.                                               |
| Top-Down Design                     | This approach begins with the highest level of abstraction and progressively breaks down the system into smaller, more manageable components. It starts with a broad overview of the system's functionality and then refines it into detailed modules. This method helps to ensure that the overall architecture aligns with the requirements and allows for easier identification of dependencies and interfaces. |
Regardless of the design method that is used, you should apply a set of basic concepts to data, architectural, interface and component-level design. 

## Generic Task Set for Design

1. Examine the information domain model and design appropriate data structures for data objects and their attributes
2. Using the analysis model, select an architectural style (pattern) that is appropriate for the software.
3. Partition the analysis model into design subsystems and allocate these subsystems within the architecture:
   1. Be certain that each subsystem is functionally cohesive
   2. Design subsystem interfaces
   3. Allocate analysis classes or functions to each subsystem
4. Create a set of design classes or components:
   1. Translate analysis class description into a design class
   2. Check each design class against design criteria; consider inheritance issues
   3. Define methods and messages associated with each design class
   4. Evaluate and select design patterns for a design class or a subsystem
5. Design any interface required with external systems or devices
6. Design the user interface:
   1. Review results of task analysis
   2. Specify action sequence based on user scenarios
   3. Create behavioral model of the interface
   4. Define interface objects, control mechanisms
   5. Review the interface design, and revise as required
7. Conduct component-level design
   1. Specify all algorithms at a relatively low level of abstraction
   2. Refine the interface of each component
   3. Define component-level data structures.
   Review each component and correct all errors uncovered.
8. Develop a deployment model

## Design Concepts

Each concept provides the software designer with a foundation from which more sophisticated design methods can be applied. Each helps you define criteria that can be used to partition software into individual components, separate of data structure detail from a conceptual representation of the software, and establish uniform criteria that define the technical quality of a software design.

| Concepts                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Abstraction                     | As different levels of abstractions are developed, you work to create both procedural and data abstractions:<br>**-A procedural abstraction:** refers to a sequence of instructions that have a specific and limited function. Where details are suppressed. An example would be the word open for a door (Open implies a long sequence of procedural steps like walk to the door, reach out and grasp knob, turn knob and pull door, step away from moving door, etc).<br>**-A data abstraction:** is a named collection of data that describes a data object. In the context of the procedural abstraction open, we can define a data abstraction called door. Like any data object, the data abstraction for door would encompass a set of attributes that describe the door (e.g door type, swing direction, opening mechanism, weight, dimensions). It follows that the procedural abstraction open would make use of information contained in the attributes of the data abstraction door.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Architecture                    | Software architecture alludes to "the overall structure of the software and the ways in which that structure provides conceptual integrity for a system". Is the structure or organization of program componentes (modules), the manner in which these components interact and the structure of data that are used by the components. A set of architectural patterns enables a software engineer to reuse design-level concepts.<br><br>A set of properties that should be specified as part of an architectural design:<br>-Structural properties: define the components of a system (modules, objects, filters) and the manner in which those components are packaged and interact with one another<br>-Extra-functional properties: How the design architecture achieves requirements for performance, capacity, and other system characteristics.<br>-Families of related systems: Draw upon repeatable patterns that are commonly encountered in the design of families of similar systems.<br><br>Given the specification of these properties, the architectural design can be represented using one or more of a number of different models:<br>-Structured models: represent architecture as an organized of program components.<br>-Framework models: increase the level of design abstraction by attempting to identify repeatable architectural design frameworks (patterns) that are encountered in similar types of applications<br>-Dynamic models: address the behavioral aspects of the program architecture, indicating how the structure or system configuration may change as a function or external events.<br>-Process models: focus on the design of the business or technical process that the system must accommodate.<br>-Functional models: can be used to represent the functional hierarchy of a system<br><br>A number of different Architectural Description Languages (ADLs) have been developed to represent these models.<br> |
| Patterns                        | A design pattern describes a design structure that solves a particular design problem within a specific context and amid "forces" that may have an impact on the manner in which the pattern is applied and used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Separation of Concerns          | Is a design concept that suggests that any complex problem can be more easily handled if it is subdivided into pieces that can each be solved and/or optimized independently. A concern is a feature or behavior that is specified as part of the requirements model for the software. Divide and conquer! This is manifested in other related design concepts: modularity, aspects, functional independence and refinement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Modularity                      | Software is divided into separately named and addressable components, sometimes called modules, that are integrated to satisfy problem requirements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Information Hiding              | Suggests that modules be "characterized by design decisions that (each) hides from all others". In other words, modules should be specified and designed so that information contained within a module is inaccesible to other modules that have no need for such information. The use of it can benefit when modification are required during testing and later during software maintenance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Functional Independence         | Is achieved by developing modules with "single-minded" function and an "aversion" to excessive interaction with other modules. In another way, you should design software so that each module addresses a specific subset of requirements and has a simple interface when viewed from other parts of the program structure.<br><br>Independence is assessed two qualitative criteria: cohesion and coupling.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Refinement                      | Helps you to reveal low-level details as design progresses. Refinement is actually a process of elaboration. You begin with a statement of function (or description of information) that is defined at a high level of abstraction. That is, the statement describes function or information conceptually but provides no indication of the internal workings of the function or the internal structure of the information. You then elaborate on the original statement, providing more and more detail as each successive refinement (elaboration) occurs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Aspects                         | As requirements analysis occurs, a set of "concerns" is uncovered. These concerns "include requirements, use cases, features, data structures, quality-of-service issues, variants, intellectual property boundaries, collaborations, patterns and contracts". Ideally a requirements models can be organized in a way that allows you to isolate each concern (requirement) so that it can be considered independently. In practice, however, some of these concepts span the entire system and cannot be easily compartmentalized. <br><br> <br>An aspect is a representation of crosscutting concern. In an ideal context, an aspect is implemented as a separate module (component) rather than as software fragments that are "scattered" or "tangled" throughout many components.  To accomplish this, the design architecture should support a mechanisms for defining an aspect—a module that enables the concerns to be implemented across all other concerns that it crosscuts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Refactoring                     | Refactoring is a reorganization technique that simplifies the design (or code) of a component without changing its function or behavior. Remove redundancy, unused design elements, inefficient or unnecessary algorithms, poorly constructed or inappropriate data structures, or any other design failure that can be corrected to yield a better design.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Object-Oriented Design Concepts | Is widely used in modern software engineering.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Design Classes                  | Design classes refer to the blueprint or structure of how a software system will be constructed.<br><br>The analysis model defines a set of analysis classes. Each of these classes describes some element of the problema domain, focusing on aspects of the problem that are user visible. The level of abstraction is relatively high. As the design model evolves, you will define a set of design classes that refine the analysis classes by providing design detail that will enable the classes to be implemented, and implement a software infrastructure that supports the business solution. Five different types of design classes, each representing a different layer of the design architecture, can be developed. <br>-User interface: define all abstractions that are necessary for Human Computer Interaction.<br>-Business domain classes: identify the attributes and services (methods) that are required to implement some element of the business domain that was defined by one or more analysis classes.<br>-Process classes: implement lower-level business abstractions required to fully manage the business domain classes<br>-Persistent classes: represent the data stores that will persist beyond the execution of the software<br>-System classes: implement software management and control functions that enable the system to operate and communicate within its computing environment and with the outside world.<br><br>As the architecture forms, the level of abstraction is reduced as each analysis class is transformed into a design representation. That is, analysis classes represent data object using the jargon of the business domain. Design classes present significantly more technical detail as guide for implementation.<br><br>Four characteristics of a well-formed design class:<br>-Complete and sufficient<br>-Primitiveness<br>-High cohesion<br>-Low coupling                                 |
| Dependency Inversion            | The structure of many older software architectures is hierarchical. At the top of the architecture, "control" components rely on lower-level "worker" components to perform various cohesive tasks. High levels modules should not depend upon low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Design for Test                 | TDD says write test before implementing any other code. Test fast, fail fast, adjust fast.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

### Design Model

An overarching framework that includes all design classes and their relationships, as well as architectural decisions and patterns. It provides a complete picture of how the system will be structured and implemented.

The design model can viewed in two different dimensions as illustrated in the Process Dimension. The process dimension indicates the evolution of the design model as design tasks are executed as part of the software process. The abstraction dimension represents the level of detail as each element of the analysis model is transformed into a design equivalent and then refined iteratively.

![](images/Pasted%20image%2020240930015645.png)

#### Design Classes 

Details specific components, including methods, properties, and interactions necessary for implementation. It’s more about the technical aspects of how classes will function in the code.


In system design, design classes refer to the blueprint or structure of how a software system will be constructed. These classes outline the organization and behavior of various components within the system. Design classes delve into the specifics of how the system will operate, focusing on factors like efficiency, scalability, and maintainability.

- Design classes encapsulate the implementation details, such as methods, attributes, and relationships between different parts of the system.
- They define the internal workings of the software, including algorithms, data structures, and interactions between modules.
- Design classes build upon the findings from analysis classes, which identify the requirements and goals of the system without diving into implementation details.
- Design classes translate these requirements into a concrete plan for how the system will be built.

Overall, design classes play a crucial role in system design by providing a structured framework for developers to follow during the implementation phase.

##### Characteristics of Design Classes

- Focus on specifying how the system will be built and operated.
- Concrete representation detailing methods, attributes, and interactions.
- Incorporate implementation details, such as algorithms and data structures.
- Translate requirements into a structured plan for development.
- Typically depicted through class diagrams, sequence diagrams, or design patterns.

##### Usage of Design Classes

- Follow analysis classes to translate requirements into a detailed design.
- Specify the internal structure and behavior of software components.
- Address concerns related to efficiency, reusability, and maintainability.
- Serve as a blueprint for coding and implementation.
- Used to create class diagrams, sequence diagrams, and design documentation for developers.


This table illustrates the key differences between analysis classes and design classes:

| Aspect          | Analysis Classes                                                | Design Classes                                                                |
| --------------- | --------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| Purpose         | Identify requirements and understand problem domain             | Define how the system will be built and operated                              |
| Focus           | What the system needs to do (functional requirements)           | How the system will accomplish its tasks (implementation details)             |
| Level of Detail | High-level, focusing on entities, attributes, and relationships | Detailed, specifying methods, attributes, and interactions                    |
| Implementation  | No implementation details, abstract representation              | Implementation details specified, concrete representation                     |
| Dependencies    | Depends on user needs, business processes, and external systems | Builds upon analysis classes, translating requirements into a structured plan |
| Deliverables    | Use cases, user stories, domain models                          | Class diagrams, sequence diagrams, design patterns                            |
| Timing          | Early stage of system development, before design                | Follows analysis, comes before implementation                                 |
| Flexibility     | More flexible and subject to change during analysis phase       | Less flexible, changes may require more effort during design phase            |

#### Elements of the Design Model

The elements of the design model use many of the same UML diagrams that were used in the analysis model. The difference is that these diagrams are refined and elaborated as part of design; more implementation-specific detail is provided, and architectural structure and style, components that reside within the architecture and interfaces between the components and with the outside world are all emphasized.

In most cases preliminary architectural design sets the stage and is followed by interface design and component-level design, which often occur in parallel. The deployment model is usually delayed until the design has been fully developed.

##### Data Design Elements

Data design (sometimes referred to as data architecting) creates a model of data/or information that is represented at a high level of abstraction (the customer/user's view of data). In many software applications, the architecture of the data will have a profound influence on the architecture of the software that must process it.

At the program-component level, the design of data structures and the associated algorithms required to manipulate them is essential to the creation of high-quality applications. At the application-level, the translation of a data model into a database is pivotal to achieving the business objectives of a system. At the business level, the collection of information stored in disparate database and reorganized into a "data warehouse" enables data mining or knowledge discovery that can have an impact on the success of the business itself. In every case, data design plays an important role.

##### Architectural Design Elements

The architectural design for software is the equivalent to the floor plan of a house. The architectural model is derived from three sources:
1. Information about the application domain for the software to be built
2. Specific requirements model elements such as use cases or analysis classes, their relationships and collaborations for the problem at hand
3. Availability of the architectural styles and patterns
The architectural design element is usually depicted as a set of interconnected subsystems, often derived from analysis packages within the requirements model. Each subsystem may have its own architecture (e.g., a graphical user interface might be structured according to a pretexting architectural style for user interfaces). 

##### Interface Design Elements

The interface design elements for software depict information flows into and out of a system and how it is communicated among the components defined as part of the architecture.

There are three important elements of interface design:
1. The user interface (UI)
2. External interfaces to other systems, devices, networks, or other producers or consumers of information
3. Internal interfaces between various design components.
These interface design elements allow the software to communicate externally and enable internal communication and collaboration among the components that populate the software architecture

The design of internal interface is closely aligned with component-level design. Design realizations of analysis classes represent all operations and the messaging schemes required to enable communication and collaboration between operations in various classes. Each message must be designed to accommodate the requisite information transfer and the specific functional requirements of the operation that has been requested.

##### Component-Level Design Elements

The component-level design for software is the equivalent to a set of detailed drawings (and specifications) for each room in a house.

The component-level design for software fully describes the internal detail of each software component. The component level design defines data structures for all local data objects and algorithmic detail for all processing that occurs within a component and interface that allows access to all component operations (behaviors). A component is represented in UML diagrammatic form. The design details of a component can be modeled at many different levels of abstraction.
##### Deployment-Level Design Elements

Deployment level design elements indicate how software functionality and subsystems will be allocated within the physical computing environment that will support the software. During design, a UML deployment diagram is development and then. refined.





## System Architecture

A system architecture is a representation of a system in which there is a mapping of functionality onto hardware and software components, a mapping of the software architecture onto the hardware architecture, and a concern for the human interaction with these components. That is, system architecture is concerned with a total system, including hardware, software and humans.

A system architecture will determine, for example, the functionality that is assigned to different processors and the type of network that connect those processors. The software architecture on each of those processors will determine how this functionality is implemented and how the various processors interact through the exchange of messages on the network.

## Software Design

Software design provides a **design plan** that describes the elements of a system, how they fit, and work together to fulfill the requirement of the system. The objectives of having a design plan are as follows:
- To negotiate system requirements, and to set expectations with customers, marketing, and management personnel.
- Act as a blueprint during the development process.
- Guide the implementation tasks, including detailed design, coding, integration, and testing.

There is a distinct difference between the terms architecture and design. A design is an instance of an architecture similar to an object being an instance of a class. So, there is one architecture, but many designs can be created based on that architecture. Therefore, you cannot mix "architecture" and "design" with each other. The elements and structures that are defined as part of an architecture are root of every design. Design begins with a consideration of architecture.
![](images/Pasted%20image%2020241104134640.png)


![](images/Pasted%20image%2020241104135028.png)


## Software Architecture

Software architecture is the high-level structure of a software system, defining its components, their relationships, and principles guiding its design and evolution. It servers a blueprint addressing both functional and non-functional requirements.

There are four types of architecture from the viewpoint of an enterprise and collectively, these architectures are referred to as enterprise architecture.

- **Business architecture** − Defines the strategy of business, governance, organization, and key business processes within an enterprise and focuses on the analysis and design of business processes.
- **Application (software) architecture** − Serves as the blueprint for individual application systems, their interactions, and their relationships to the business processes of the organization.
- **Information architecture** − Defines the logical and physical data assets and data management resources.
- **Information technology (IT) architecture** − Defines the hardware and software building blocks that make up the overall information system of the organization.


![](images/Pasted%20image%2020241104135706.png)


The software architecture is the set of structures needed to reason about the system. These structures comprise software elements, relations among them, and properties of both. Architecture is importnt for a wide vairety of reasons, between them:
* An architecture will inhibit or enable a system's driving quality attributes.
* The decisions made in an architecture allow you to reason about and manage change as the system evolves
* The analysis of an architecture enables early prediction of a system's qualities.
* A document architecture enhances communication among stakeholders.
* The architecture is a carrier of the earliest and hence most fundamental, hardest-to-change design decisions
* An architecture defines a set of constraints on subsequent implementation
* The architecture influences the structure of an organization and vice versa.
* An architecture can provide the basis for evolutionary, or even throwaway prototyping.
* An architecture is the key artifact that allows the architect and the project manager to reason about cost and schedule
* An architecture can be created as a transferable, reusable model that forms the heart of a product line
* Architecture-centric development focuses attention on the assembly of components, rather than simply on their creation
* By restricting design alternatives, architecture channels the creativity of developers, reducing design and system complexity
* An architecture can be the foundation for training a new team member.

No matter what software development process or life-cycle model you're using, there are a number of activities that are involved in creating a software architecture, using that architecture to realize a complete design, and then implementing or managing the evolution of a target system or application. The process you use will determinate how often and when you revisit and elaborate each of these activities. These activities include:

1. Making a business case for the system
2. Understanding the architecturally significant requirements
3. Creating of selecting the architecture
4. Documenting and communicating the architecture
5. Analyzing or evaluating the architecture
6. Implementing and testing the system based on the architecture
7. Ensuring that the implementation conforms to the architecture

Software architecture consists of the:

| Component of architecture    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Structure                    | Refers to the type of architecture style (or styles) the system is implemented in (such as microservices, layered or microkernel). Describing an architecture solely by the structure deos not wholly elucidate an architecture. When an architect is asked to describe an architecture and that architect responds "it's a microservices architecture". Here, the architect is only talking about the structure of the system, but no the architecture of the system.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Architecture characteristics | The architecture characteristics define the success criteria of a system, which is generally orthogonal to the functionality of the system. Examples are availability, reliability, testability, scalability, security, agility, fault tolerance, elasticity, recoverability, performance, deployability, learnability.<br><br>**An architecture characteristic meets the criteria:**<br>-Specifies a non-domain design consideration<br>-Influences some structural aspect of the design<br>-Is critical or important to application success<br><br>They can be implicit (rarely appear in requirements, for example, availability, reliability, and security) or explicit(appear in requirements documents or other specific instructions). They can be extracted from domain concerns, requirements and implicit domain knowledge. Understanding the key domain goals and domain situation allows an architect to translate those domain concerns to "-ilities", which then forms the basis for cforrect and justifiable architecture decisions.<br><br>-**Operational architecture characteristics**: Availability, continuity, performance, recoverability, reliability/safety, robustness, scalability<br>-**Structural architecture characteristics**: configurability, extensibility, installability, leverageability/reuse, localization, maintainability, portability, supportability, upgradeability.<br>-**Cross-cutting architecture characteristics**: accessibility, archivability, authentication, authorization, legal, privacy, security, supportability, usability/achievability.<br>                                                                              |
| Architecture decisions       | These define the rules for how a system should be constructed. They form the constraints of the system and direct the development teams on what is and what isn't allowed. Examples of architecture are:<br>-**Particular technology** where the technology supports a particular architecture characteristic<br>-**Architectural significant decisions**: those decision that affect the structure, nonfunctional characteristics, dependencias, interfaces or construction techniques.<br>--**Structure** refers to decision that impact the pattern or styles of architectures being used: a example is the decision to share data between a set of microservices. This decision impacts the bounded context of the microservices, and as such affects the structure of the application<br>--**The nonfunctional characteristics**: If a choice of technology impacts performance, and performance is an important aspect of the application, then it becomes an architecture decision.<br>--**Dependencies**: refer to coupling points between components and/or services within the system, which in turn impact overall scalability, modularity, agility, testability, reliability, and so on<br>--**Interfaces**: refer how to services and components are accessed and orchestrated, usually through a gateway, integration hub, services bus, or API proxy. Interfaces usually involve defining contracts, including the versioning and deprecation strategy of those contracts.<br>--**Construction techniques**: refer to decision about platforms, frameworks, tools and even processes that, although technical in nature, might impact some aspect of the architecture. |
| Design principles            | A design principle differs from an architecture decision in that a design principle is a **guideline** rather than a hard-and-fast **rule**. A design principle can be used to provide guidance for the preferred method to allow the developer to choose a more appropriate communication protocol given a specific circumstance                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

### Laws of Software Architecture

1. Everything in software architecture is a trade-off
2. If an architect thinks they have discovered something that isn't a trade-off, more likely they just haven't identified the trade-off yet.
3. Why is more important than how
In architecture there are no right or wrong answers in architecture—only trade-offs. The architectural thinking requires the architect to analyze the trade-offs associated with each option and select the best one given the specific situation
1. Never shoot for the best architecture, but rather the least worst architecture.

Avoid the generic architecture, it means one that supports all the architecture characteristics. Each architecture characteristic the architecture supports complicates the overall system design; supporting too many architecture characteristics leads to greater and greater complexity before the architect and developers have even started addressing the problem domain.

Translation of domain concerns to architecture characteristics

| Domain concern           | Architecture Characteristics                                                              |
| ------------------------ | ----------------------------------------------------------------------------------------- |
| Mergers and acquisitions | Interoperability, scalability, adaptability, extensibility                                |
| Time to market           | Agility, testability, deployability                                                       |
| User satisfaction        | Performance, availability, fault tolerance, testability, deployability, agility, security |
| Competitive advantage    | Agility, testability, deployability, scalability, availability, fault tolerance           |
| Time and budget          | Simplicity, feasibility                                                                   |

**Design vs Architecture**

| Characteristics | Architecture                           | Design                      |
| --------------- | -------------------------------------- | --------------------------- |
| Level           | High                                   | Low                         |
| Approach        | Components, interaction and technology | Module and class structures |
| Objective       | Non functional requirements            | Functional requirements     |
| Flexibility     | Lower                                  | Higher                      |

###  Quality Attributes

A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders. 

| Category                    | Quality Attribute    | Description                                                                                                                                                                   |
| --------------------------- | -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Design Qualities            | Conceptual Integrity | Defines the consistency and coherence of the overall design. This includes the way components or modules are designed.                                                        |
|                             | Maintainability      | Ability of the system to undergo changes with a degree of ease.                                                                                                               |
|                             | Reusability          | Defines the capability for components and subsystems to be suitable for use in other applications.                                                                            |
| Run-time Qualities          | Interoperability     | Ability of a system or different systems to operate successfully by communicating and exchanging information with other external systems written and run by external parties. |
|                             | Manageability        | Defines how easy it is for system administrators to manage the application.                                                                                                   |
|                             | Reliability          | Ability of a system to remain operational over time.                                                                                                                          |
|                             | Scalability          | Ability of a system to either handle the load increase without impacting the performance of the system or the ability to be readily enlarged.                                 |
|                             | Security             | Capability of a system to prevent malicious or accidental actions outside of the designed usages.                                                                             |
|                             | Performance          | Indication of the responsiveness of a system to execute any action within a given time interval.                                                                              |
|                             | Availability         | Defines the proportion of time that the system is functional and working. It can be measured as a percentage of the total system downtime over a predefined period.           |
| System Qualities            | Supportability       | Ability of the system to provide information helpful for identifying and resolving issues when it fails to work correctly.                                                    |
|                             | Testability          | Measure of how easy it is to create test criteria for the system and its components.                                                                                          |
| User Qualities              | Usability            | Defines how well the application meets the requirements of the user and consumer by being intuitive.                                                                          |
| Architecture Quality        | Correctness          | Accountability for satisfying all the requirements of the system.                                                                                                             |
| Non-runtime Quality         | Portability          | Ability of the system to run under different computing environment.                                                                                                           |
|                             | Integrality          | Ability to make separately developed components of the system work correctly together.                                                                                        |
|                             | Modifiability        | Ease with which each software system can accommodate changes to its software.                                                                                                 |
| Business quality attributes | Cost and schedule    | Cost of the system with respect to time to market, expected project lifetime & utilization of legacy.                                                                         |
|                             | Marketability        | Use of system with respect to market competition.                                                                                                                             |

The quality attributes can be divided in two broader categories:

| Category    | Description                                                                                                                                                                                        | Quality Attribute                                                               |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| **Static**  | Reflect the structure of a system and organization, directly related to architecture, design, and source code. <br>They are invisible to end-user, but affect the development and maintenance cost | -Modularity<br>-Testability<br>-Maintainability<br>-Reusability<br>-Scalability |
| **Dynamic** | Reflect the behavior of the system during its execution. They are directly related to system’s architecture, design, source code, configuration, deployment parameters, environment, and platform. | -Performance<br>-Availability<br>-Security<br>-Reliability<br>-Scalability      |

And can be categorized as the following table:

| Category          | Description                                                                   | Quality Attribute                                                        |
| ----------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| General Scenario  | Those that are system independent and can, potentially, pertain to any system | -Performance<br>-Security<br>-Usability<br>-Reliability<br>-Scalability  |
| Concrete Scenario | Those that are specific to the particular system under consideration          | -Performance<br>-Availability<br>-Security<br>-Usability<br>-Reliability |

No matter the source, all requirements encompass the following categories:

| Categories                     | Description                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Functional Requirements        | They state what the system must do, and how it must behave or react to runtime stimuli.                                                                                                                                                                                                                                                                                |
| Quality Attribute Requirements | These are qualifications of the functional requirements or the overall product. a qualification of a functional requirement is an item such as how fast the function must be performed, or how resilient it must be to erroneous input. A qualification of the overall product is an item such as the time to deploy the product or a limitation on operational costs. |
| Constraints                    | A constraint is a design decision with zero degrees of freedom                                                                                                                                                                                                                                                                                                         |

The architecture must respond to each of these kinds of requirements:
1. Functional requirements are satisfied by assigning an appropriate sequence of responsibilities throughout the design.
2. Quality attribute requirements are satisfied by the various structures designed into the architecture, and the behaviors and interactions of the elements that populate those structures.
3. Constraints are satisfied by accepting the design decision and reconciling it with other affected design decisions.

Implementing quality attributes makes it easier to differentiate a good system from a bad one. Attributes are overall factors that affect runtime behavior, system design, and user experience.

![](images/Pasted%20image%2020241008144137.png)
#### Quality Attribute Scenarios

A quality attribute requirement should be unambiguous and testable. We use a common form to specify (the act of describing it with enough clarity and detail) all quality attribute requirements through Quality Attribute Scenarios.

**Quality attribute scenarios** are detailed, specific descriptions of how a system should meet certain **quality attributes**. These scenarios help set clear, measurable expectations for the system’s behavior under specific conditions, ensuring it not only functions correctly but also meets particular quality standards.

Our common form for quality attribute expression has these parts:
* **Stimulus**: To describe an event arriving at the system.
* **Stimulus Source**: A stimulus must have a source—it must come form somewhere.
* **Response**: How the system should respond to the stimulus must also be specified.
* **Response measure**: Determining whether a response is satisfactory—whether the requirement is satisfied—is enabled by providing a response measure. 
* **Environment**: The environment of a requirement is the set of circumstances in which the scenario takes place. The environment acts as a qualifier on the stimulus.
* **Artifact**: Is the portion of the system to which the requirements applies.

![](images/Pasted%20image%2020241006173258.png)
![](images/Pasted%20image%2020241006173308.png)

#### Achieving Quality Attributes Through Tactics

Quality Attribute Requirements specify how the system should respond to meet business goals. To achieve these goals, software architects use architectural tactics, which are design decisions that directly influence the system's response to various stimuli (e.g., load, failures, etc).

**Tactics** are design decisions that influence the control of a quality attribute response. They are simpler than patterns. They focus on the control of a single quality attribute response. 

If no pattern exist to realize the architect's design goal, tactics allow the architect to construct a design fragment from "first principles". And by cataloging tactics, we provide a way of making design more systematic within some limitations. And the choice of which tactic to use depends on factors such as tradeoffs among other quality attributes and the cost to implement. In addition, the application of a tactic depends on the context.

Tactics categorization have been established for the quality attributes of availability, deployability, energy efficiency, interoperability, modifiability, performance, safety, security, testability, and usability.


![](images/Pasted%20image%2020241006174733.png)

![](images/Pasted%20image%2020241109143034.png)

Each of these tactics is an option for the architect. They may be instantiated via coding, via patterns, or via external components such as frameworks—but they are architectural.
#### Guiding Quality Design Decisions

Recall that one can view an architecture as the result of applying a collection of design decisions. Seven categories of design decisions are presented. They provide a rational division of concerns. These categories might overlap, but it's all right if a particular decision exists in two different categories, because the concern of the architect is to ensure that every important decision is considered. 

| Design Decision                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Allocation of Responsibilities       | Decisions involving allocation of responsibilities include the following:<br>-Identifying the important responsibilities, including basic system functions, architectural infrastructure, and satisfaction of quality attributes.<br>-Determining how these responsibilities are allocated to non-runtime and runtime elements (namely, modules, components and connectors)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Coordination Model                   | Software works by having elements interact with each other through designed mechanisms. These mechanisms are collectively referred to as a coordination model. Decisions about the coordination model include these:<br>-Identifying the elements of the system that must coordinate, or are prohibited from coordinating.<br>-Determining the properties of the coordination, such as timeliness, currency, completeness, correctness, and consistency.<br>-Choosing the communication mechanisms (between systes, between our system and external entities, between elements of our system) that realize those properties. Important properties of the communication mechanisms include stateful versus stateless, synchronous versus asynchronous, guaranteed versus nonguaranteed delivery, and performance-related properties such as throughput and latency.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Data Model                           | Every system must represent artifacts of system-wide interest—data—in some internal fashion. The collection of those representations and how to interpret them is referred to as the data model. Decisions about the data model include the following:<br>-Choosing the major data abstractions, their operations, and their properties. This includes determining how the data items are created, initialized, accessed, persisted, manipulated, translated and destroyed<br>-Compiling metadata needed for consistent interpretation of the data.<br>-Organizing the data. This includes determining whether the data is going to kept in a relational database, a collection of objects or both. If both, then the mapping between the two different locations of the data must be determined.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Management of Resources              | An architect may need to arbitrate the use of shared resources in the architecture. These include hard resources (e.g., CPU memory, battery, hardware, buffers, system clock, I/O ports) and soft resources (e.g., system locks, software buffers, thread pools, and non-thread-safe code). Decisions for management of resources include the following:<br>-Identifying the resources that must be managed and determining the limits for each.<br>-Determining which system element(s) manage each resources<br>-Determining how resources are shared and the arbitration strategies employed when there is contention.<br>-Determining the impact of saturation on different resources. For example, as a CPU becomes more heavily loaded, performance usually just degrades fairly steadily. On the other hand, when you start to run out of memory, at some point you start paging/swapping intensively and your performance suddenly crashes to a halt.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Mapping among Architectural Elements | An architecture must provide two types of mappings. First there is mapping between elements in different types of architecture structures—for example mapping from units of development (modules) to units of execution (threads or processes). Next, there is mapping between software elements and environment elements—for example, mapping from processes to the specific CPUS where these processes will execute. Useful mappings include these:<br>-The mapping of modules and runtime elements to each other—that is, the runtime elements that are created from each module; the modules that contain the code for each runtime element.<br>-The assignment of runtime elements to processors.<br>-The assignment of items in the data model to data stores.<br>-The mapping of modules and runtime elements to units of delivery                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Binding Time Decisions               | Binding time decisions introduce allowable ranges of variation. This variation can be bound at different times in the software life cycle by different entities—from design time by a developer to runtime by an end user. A binding time decision establishes the scope, the point in the life cycle, and the mechanisms for achieving the variation. Examples<br>-For allocation of responsibilities, you can have build-time selection of modules via a parameterized makefile.a<br>-For choice of coordination model, you can design runtime negotiation of protocols.<br>-For resource management, you can design a system to accept new peripheral devices plugged in at runtime, after which the system recognizes them and downloads and installs the right drivers automatically.<br>-For choice of technology, you can build an app store for a smartphone that automatically downloads the version of the app appropriate for the phone of the customer buying the app.<br><br>When making binding time decisions, you should consider the costs to implement the decision and the costs to make a modification after you have implemented the decision.                                                                                                                                                                                                                                                                                                                                      |
| Choice of Technology                 | Every architecture decision must eventually be realized using a specific technology. Sometimes the technology selection is made by others, before the intentional architecture design process begins. In this case, the chose technology becomes a constraint on decision in each of our seven categories. In other cases, the architect must choose a suitable technology to realize a decision in every one of the categories. Choice of technology decisions involve the following:<br>-Deciding which technologies are available to realize the decision made in the other categories.<br>-Determining whether the available tools to support this technology choice (IDEs, simulators, testing tools, etc) are adequate for development to proceed.<br>-Determining the extent of internal familiarity as well as the degree of external support available for the technology (such as courses, tutorials, examples, and availability of contractor who can provide expertise in a crunch) and deciding whether this is adequate to proceed.<br>-Determining the side effects of choosing a technology, such as a require coordination model or constrained resource management opportunities.<br>-Determining whether a new technology is compatible with the existing technology stack. For example, can the new technology run on top of or alongside the existing technology stack? Can it communicate with the existing technology stack? Can the new technology be monitored and managed?<br> |
#### Architectural Decisions

Architectural decisions are key choices made during the design of a software system that shape its structure and behavior. They typically involve:
- **Technology Selection**: Choosing programming languages, frameworks, and tools that best meet project needs.
- **Component Design**: Determining how to structure components, including their responsibilities and interactions.
- **Architectural Patterns**: Selecting patterns (e.g., microservices, layered architecture) that address specific requirements.
- **Data Management**: Deciding how data will be stored, accessed, and managed, including database choices and data flow.
- **Scalability Considerations**: Planning for future growth in users and data, including load balancing and caching strategies.
- **Security Measures**: Implementing strategies to protect the system from threats, such as authentication and encryption.
- **Deployment Strategies**: Choosing how and where the application will be deployed, including cloud services or on-premises infrastructure.
- **Performance Trade-offs**: Balancing speed, resource usage, and responsiveness based on system requirements.

Architecture Decision Description Template

* **Design Issue**: Describe the architectural design issues that are to be addressed.
* **Resolution**: State the approach you've chosen to address the design issue.
* **Category**: Specify the design category that the issue and resolution address (e.g., data design, content structure, component structure, integration, presentation)
* **Assumptions**: Indicate any assumptions that helped shape the decision.
* **Constraints**: Specify any environmental constraints that helped shape the decision (e.g., technology standards, available patterns, project-related issues).
* **Alternatives**: Briefly describe the architectural design alternatives that were considered and why they were rejected
* **Argument**: State why you chose the resolution over the alternatives.
* **Implications**: Indicate the design consequences of making the decision. How will the resolution affects other architectural design issues? Will the resolution constrain the design in any way?
* **Related decisions**: What other documented decisions are related to this decision?
* **Related concerns**: What other requirements are related to this decision?
* **Work products**: Indicate where this decision will be reflected in the architecture description
* **Notes**: Reference any team notes or other documentation that was used to make the decision.


Some of these decisions include:
* Software system organization
* Selection of structural elements and their interfaces as defined by their intended collaborations
* Composition of these elements into increasingly larger subsystems
* Choices of architectural patterns
* Application technologies
* Middleware assets
* Programming language

### Architectural Descriptions

Architectural descriptions are comprehensive sets of work products that represent various views of a software system's architecture. They capture different aspects through multiple metaphors, each addressing specific stakeholder concerns. These views can include:
1. **Blueprint Metaphor**: Emphasizes the structural layout and design of the system, providing a detailed plan for construction and implementation.
2. **Language Metaphor**: Focuses on the communication and interaction between components, highlighting how they "speak" to each other through interfaces and protocols.
3. **Decision Metaphor**: Captures the rationale behind architectural choices, illustrating the trade-offs and considerations that influenced design decisions.
4. **Literature Metaphor**: Views the architecture as a narrative, telling the story of the system’s evolution, goals, and the relationships among its components, making it relatable to stakeholders.
An architectural description of a software-based system must exhibit characteristics that combine these metaphors. 

The IEEE in Recommended Practice for Architectural Description of Software Intensive Systems, provide the following objectives:
1. To establish a conceptual framework and vocabulary for use during the design of software architecture
2. To provide detailed guidelines for representing an architectural description
3. An architectural description (AD) represents multiple views, where each view is "a representation of a whole system from the perspective of a related set of stakeholder concerns"

### Architectural Genres

The architectural genre will often dictate the specific architectural approach to the structure that must be built. In the context of architectural design, genre implies a specific category within the overall software domain. Architectural Genre is used to define the architectural approach for the build of any structure.

 The architectural genres for software-based systems as suggested by Grady Booch are as follows –

- **Artificial Intelligence**: Systems which simulate or augment human cognition, locomotion, or other organic processes.
- **Commercial and Non-Profit**: Here, it includes systems that are fundamental to the operation of a business enterprise.
- **Communication**: Systems that provide the infrastructure for transferring and managing data, for connecting users of the data, or for presenting data at the edge of an infrastructure.
- **Content Authoring**: It includes systems that are used to create or manipulate textual or multimedia artifacts.
- **Device**: Systems that interact with the physical world to provide some point service for an individual.
- **Entertainment and Sports**: It includes those systems that manage public events or that provide a large group entertainment experience.
- **Financial**: Systems that provide the infrastructure for managing and transferring money and other securities.
- **Games**: This includes the systems that provide an entertainment experience to individuals or groups.
- **Government**: This includes those systems that support the conduct and operations of a local, state, federal, global, or other political entity.
- **Industrial**: Systems that simulate or control physical processes.
- **Legal**: Systems that support the legal industry
- **Medical**: It includes systems that diagnose or heal or that contribute to medical research.
- **Military**: Systems for consultation, command, communications, intelligence, and control as well as offensive and defensive weapons.
- **Operating Systems**: It includes systems that sit just above hardware to provide basic software services.
- **Scientific**: This includes systems that are used for scientific research and applications.
- **Transportation**: It includes systems that control water, ground air, or space vehicles.

### Architectural Styles

An architectural style is a transformation that is imposed on the design of the entire system. The intent is to establish a structure for all componentes of the system. In the case where an existing architecture is to be reengineered, the imposition of an architectural style will result in fundamental changes to the structure of the software including a reassignment of the functionality of components.

The **architectural style** is a set of principles which shapes an application. It defines an abstract framework for a family of system in terms of the pattern of structural organization.

Architectural styles are standardized methods of organizing software systems, defining the relationships among components and their interactions. They provide a framework for system design, guiding decision-making and ensuring consistency.

The architectural style is responsible to:
- Provide a lexicon of components and connectors with rules on how they can be combined.
- Improve partitioning and allow the reuse of design by giving solutions to frequently occurring problems.
- Describe a particular way to configure a collection of components (a module with well-defined interfaces, reusable, and replaceable) and connectors (communication link between modules).

The software that is built for computer-based systems exhibit one of many architectural styles. Each style describes a system category that encompasses −
- A set of component types which perform a required function by the system.
- A set of connectors (subroutine call, remote procedure call, data stream, and socket) that enable communication, coordination, and cooperation among different components.
- Semantic constraints which define how components can be integrated to form the system.
- A topological layout of the components indicating their runtime interrelationships.


| Category      | Architectural Design                | Description                                                                                                                                                                                                                                                                                                                                                              |
| ------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Communication | Message Bus                         | Prescribes use of a software system that can receive and send messages using one or more communication channels                                                                                                                                                                                                                                                          |
|               | Service-Oriented Architecture (SOA) | Defines the applications that expose and consume functionality as a service using contracts and messages.                                                                                                                                                                                                                                                                |
|               | REST                                | Design web services that leverage the principles of the web. REST enables communication between client and server over HTTP, using standard operations (GET, POST, PUT, DELETE) to interact with resources, which are representations of domain entities.                                                                                                                |
| Deployment    | Client/Server                       | Separate the system into two applications, where the client makes request to the server.                                                                                                                                                                                                                                                                                 |
|               | 3-tier or N-tier                    | Separate the functionality into separate segments with each segment being a tier located on a physically separate computer                                                                                                                                                                                                                                               |
|               | Microservices                       | Structures an application as a collection of small, independent services that can be deployed separately. Each microservice is responsible for a specific function and communicates with other services via APIs. This architecture promotes scalability, maintainability, and agile development by allowing different teams to work on distinct services independently. |
| Domain        | Domain Driven Design                | Focused on modeling a business domain and defining business objects based on entities within the business domain.                                                                                                                                                                                                                                                        |
|               | Ports & Adapters / Hexagonal        | aims to decouple the core of the application (domain) from external interactions (such as databases, user interfaces, and external services). It uses "ports" to define communication interfaces and "adapters" to implement those interfaces, allowing the domain to remain independent of external technologies.                                                       |
| Structure     | Component Based                     | Breakdown the application design into reusable functional or logical components that expose well-defined communication interfaces.                                                                                                                                                                                                                                       |
|               | Layered                             | Divides the concerns of the application into stacked groups (layers).                                                                                                                                                                                                                                                                                                    |
|               | Object Oriented                     | Based on the devision of responsibilities of an application or system into objects, each containing the data and the behavior relevant to the object.                                                                                                                                                                                                                    |
|               | Microservices                       | --------                                                                                                                                                                                                                                                                                                                                                                 |

Architectural Patterns can be used in conjunction with an architectural style to shape the overall structure of a system. 

****************

**NOTE**: Design/architectural patterns are conceptual solutions to recurring design problems that exist in a defined context. Although design patterns originally focused on decisions at the object scale, including instantiation, structuring, and behavior, today there are catalogs of patterns that address decisions at varying levels of granularity.
In addition, there specific patterns to address quality attributes such as security, availability, performance, and integrability.

Some people might differentiate between what they consider to be architectural patterns and the more fine-grained design patterns. However, we believe there is no principled difference that can be solely attributed to scale. We consider a pattern to be architectural when its use directly and substantially influence the satisfaction of some a system's architectural driver.

Another important type of pattern that has significant implications for the architectural design process is deployment patterns. These patterns package key decisions that shape the system's infrastructure and have profound implications for quality attributes such as availability, performance, modifiability, and usability.

********************


### Architecture Patterns

On the other hand, an architectural Pattern expresses a fundamental structural organization schema for software systems. It provides a set of predefined subsystems, specifies their responsibilities, and includes rules and guidelines for organizing the relationships between them.


Architectural pattern provides a solution to a problem using the vocabulary defined in the related Architectural style. It provides a way to complete the implementation of a chosen style.

One or more Architectural patterns can be used in a chosen Architectural style or a combination of styles, and also a single pattern can be used in multiple styles according to the requirements of the system. An Architectural pattern doesn’t prohibit to use another pattern that will serve under the same Architectural style.


Architectural patterns:
* Is a package of design decisions that is found repeatedly in practice
* Has known properties that permit reuse
* Describes a class of architectures.

An essential part of an architecture Pattern is its focus on the problem and context as well as how to solve the problem in that context. An architecture Style focuses on the architecture approach, with more lightweight guidance on when a particular style may or may not be useful. Very informally, we can put it this way:
* Architecture Pattern: { A context, A problem, A solution } → architecture approach;
* Architecture Style: architecture approach.


Architectural Pattern imposes a transformation on the design of an architecture. However, a pattern differs from a style in a number of fundamental ways:
1. The scope of a pattern is less broad, focusing on one aspect of the architecture rather than the architecture in its entirety
2. A pattern imposes a rule on the architecture, describing how the software will handle some aspect of its functionality at the infrastructure level
3. Architectural Pattern tend to address specific behavioral issues within the context of the architecture.

Architectural patterns and tactics are ways of capturing proven good design structures, so that they can be reused.

Tactics are the "building blocks" of design, from which architectural patterns are created. Tactics are atoms and patterns are molecules. Most patterns consist of (are constructed from) several different tactics. For this reason patterns package tactics


| Type                                            | Description                                                                                                                                                                                                 |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Model-View-Controller (MVC)                     | Separates an application into three interconnected components: the Model (data), the View (user interface), and the Controller (business logic), promoting organized code and separation of concerns.       |
| Event Sourcing                                  | Stores the state of a system as a sequence of events rather than as a current state, allowing for easy reconstruction of past states and providing an audit trail.                                          |
| CQRS (Command Query Responsibility Segregation) | Separates the read and write operations in a system, using different models for querying data (reads) and for handling commands (writes), optimizing performance and scalability.                           |
| Broken Pattern                                  | Manages communication between clients and servers through a middleware broker that facilitates message passing, often used in distributed systems.                                                          |
| Pipeline pattern                                | Processes data through a series of stages or components, where each stage performs a transformation or processing step, allowing for flexible and maintainable data handling.                               |
| Model-View-ViewModel                            | A variation of MVC that separates the development of the user interface from the business logic and data model, often used in data-binding scenarios (e.g., in WPF applications).                           |
| Microkernel                                     | Separates a minimal core system from extended functionalities, enabling flexibility through plug-ins that add features without altering the core system.                                                    |
| Three-tier                                      | Divides an application into three layers: presentation, application logic, and data storage, promoting separation of concerns and facilitating maintenance.                                                 |
| Layered                                         | Organizes an application into distinct layers, where each layer has specific responsibilities, facilitating separation of concerns and easier management of dependencies.                                   |
| Shared-Data                                     | Involves multiple components sharing a common data store, allowing different parts of an application to access and manipulate the same data, which can simplify data management but may introduce coupling. |
| Client-Server                                   | A model where client devices request resources or services from centralized servers, promoting centralized control and management while enabling scalability and resource sharing.                          |
| Multi-tier                                      | Extends the three-tier architecture by adding additional layers or tiers, allowing for more complex applications with enhanced separation of concerns and modularity.                                       |

An architectural pattern establishes a relationship between:
* A context: A recurring, common situation in the world that gives rise to a problem.
* A problem: The problem, appropriately generalized, that arises in the given context. The pattern description outlines the problem and its variants, and describes any complementary or opposing forces. The description of the problem often includes quality attributes that must met.
* A solution: A successful architectural resolution to the problem, appropriately abstracted. The solution describes the architectural structures that solves the problem, including how to balance the many forces at work. The solution will describe the responsibilities of and static relationships among elements (using a module structure), or it will describe the runtime behavior of and interaction between elements.

The solution for a pattern is determined and described by:
* A set of element types (e.g., data repositories, processes, and objects)
* A set of interaction mechanisms or connectors (e.g., method calls, events, or message bus)
* A topological layout of the components
* A set of semantic constraints covering topology, element behavior, and interaction mechanisms

This { context, problem, solution } forms constitutes a template for documenting a pattern. Complex system exhibit multiple patterns at one. A web-based system might employ a three-tier client-server architectural pattern, but within this pattern it might also use replication (mirroring), proxies, caches, firewalls, MVC, and so forth, each of which may employ more patterns and tactics.

Applying patterns is not an all-or-nothing proposition. Patterns definitions given in catalogs are strict, but in practice architects may choose to violate them in small ways when there is a good design tradeoff to be had.

Patterns can be categorized by the dominant type of elements that they show: module patterns, component and connector (C&C) and allocation patterns (shows a combination of software elements and nonsoftware elements)

| Category                               | Pattern                                                                                                                                                                           |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Module patterns                        | -Layered pattern                                                                                                                                                                  |
| Component-and-connector (C&C) patterns | -Broker pattern<br>-Pipe-and-Filter pattern<br>-Client-server pattern<br>-Peer-to-Peer pattern<br>-Service-Oriented pattern<br>-Publish-Subscribe pattern<br>-Shared-Data pattern |
| Allocation patterns                    | -Allocation pattern<br>-Multi-tier pattern                                                                                                                                        |

##### Using Tactics to Augment Patterns
A pattern is described as a solution to a class of problems in general context. When pattern is chosen and applied, the context of its applications becomes very specific. To make a pattern work in a given architectural context, we need to examine it from two perspectives:
1. The inherent quality attribute tradeoffs that the pattern makes. Patterns exist to achieve certain quality attributes, and we need to compare the ones they promote (and the ones they diminish) with our needs.
2. Other quality attributes that the pattern isn't directly concerned with, but which it nevertheless affects, and which are important in our application.

Every tactic has its main effect—to manage modifiability or performance or safety, and so on—and its has its side effects, its tradeoffs. Tactics are simpler than patterns. Tactics typically use just a single structure or computational mechanisms, and they are meant to address a single architecture force. For this reason they give more precise control to an architect when making design decisions than patterns, which typically combine multiple design decisions into a package. 
### Design Patterns

Design patterns are reusable solutions to common problems that occur in software design. They provide a template for how to solve specific design issues in a flexible and efficient way. Design patterns are not finished designs; rather, they are descriptions or guidelines for how to solve a problem in a particular context. 

Design Patterns: Operate at a more granular level compared to architectural patterns. They focus on specific design problems within the components defined by architectural patterns. For instance, within an MVC architectural pattern, you might use the Observer design pattern to handle the communication between the model and the view. Design Patterns address particular design problems within the components defined by architectural patterns.

They are:
- **Reusable**: Can be applied in different situations.
- **Language-agnostic**: Can be implemented in various programming languages.
- **Descriptive**: They describe relationships between classes or objects and the roles they play.
- **Common Language**: Provide a shared vocabulary for developers to communicate design ideas.

Design Pattern deals with the development/improvement of a single component whereas Architectural Pattern deals with the overall system development/improvement.

| Type                                                                                                                                           | Pattern          | Description                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| Creational Patterns: Deal with object creation mechanisms, providing various ways to create objects while hiding the creation logic.           | Singleton        | Ensures a class has only one instance and provides a global point of access to it. Useful for managing shared resources.                            |
|                                                                                                                                                | Factory Method   | Defines an interface for creating an object but lets subclasses alter the type of created objects, promoting loose coupling.                        |
|                                                                                                                                                | Builder          | Separates the construction of a complex object from its representation, allowing for different representations using the same construction process. |
|                                                                                                                                                | Prototype        | Creates new objects by copying an existing object (prototype), useful when creating a new instance is costly.                                       |
|                                                                                                                                                | Abstract Factory | Provides an interface for creating families of related or dependent objects without specifying their concrete classes.                              |
| Structural Patterns: Concerned with how classes and objects are composed to form larger structures, focusing on the relationships between them | Adapter          | Allows incompatible interfaces to work together by wrapping an existing class with a new interface.                                                 |
|                                                                                                                                                | Decorator        | Adds behavior or responsibilities to individual objects dynamically without affecting other objects of the same class.                              |
|                                                                                                                                                | Composite        | Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly. |
|                                                                                                                                                | Facade           | Provides a simplified interface to a complex subsystem, hiding its complexities.                                                                    |
|                                                                                                                                                | Proxy            | Represents another object to control access to it, useful for lazy initialization, access control, or resource management.                          |
| Behavioral Patterns: Focus on communication between objects, defining how objects interact and collaborate to fulfill a specific task.         | Observer         | Defines a one-to-many dependency between objects, so when one object changes state, all dependents are notified and updated automatically.          |
|                                                                                                                                                | Strategy         | Defines a family of algorithms, encapsulating each one to make them interchangeable, allowing the algorithm to vary independently.                  |
|                                                                                                                                                | Command          | Encapsulates a request as an object, allowing for parameterization of clients and supporting undoable operations.                                   |
|                                                                                                                                                | Iterator         | Provides a way to access elements of an aggregate object sequentially without exposing its underlying representation.                               |
|                                                                                                                                                | Mediator         | Defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing direct interactions between them.         |

### Base patterns

| Pattern             | Description                                                                                                                                                      | When to use                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Gateway             | A design pattern that acts as an entry point for communication between systems, often encapsulating the details of external APIs or services.                    | Use when you need to simplify or abstract interactions with external systems, providing a single point for managing calls and data transformations.                                                                                                                                                                                                                                                                                                                          |
| Mapper              | A pattern that translates data between objects in different representations, often used for converting between domain models and data models.                    | Use when you need to decouple the structure of data from its representation, especially in scenarios involving complex object mappings or transformations.<br><br>You should only use a _Mapper_ **when you need to ensure that neither subsystem has a dependency on this interaction**. The only time this is really important is when the interaction between the subsystems is particularly complicated and somewhat independent to the main purpose of both subsystems. |
| Layer Supertype     | A pattern where a common superclass provides shared behavior or properties for multiple subclasses, promoting code reuse.                                        | Use when you have multiple classes that share common functionality, allowing for a cleaner and more maintainable codebase.                                                                                                                                                                                                                                                                                                                                                   |
| Separated Interface | A pattern that defines a clear separation between the interface and implementation, allowing for flexibility and easier testing.                                 | Use when you want to enable different implementations of an interface without altering the code that depends on it, facilitating better maintainability and testability.                                                                                                                                                                                                                                                                                                     |
| Registry            | A pattern that provides a centralized place to manage instances or configurations of services or objects, often used for service discovery.                      | Use when you need to manage a collection of services or objects that can be dynamically accessed and configured at runtime.                                                                                                                                                                                                                                                                                                                                                  |
| Value Object        | A design pattern that encapsulates a set of attributes that are treated as a single unit, often immutable and defined by their attributes.                       | Use when you want to represent simple entities without identity, focusing on their attributes rather than their lifecycle or behavior.                                                                                                                                                                                                                                                                                                                                       |
| Special Case        | A pattern that handles specific situations or conditions within the overall system, often encapsulating unique behavior or rules.                                | Use when you need to accommodate exceptions or special rules that don't fit the general model, ensuring that core logic remains clean.                                                                                                                                                                                                                                                                                                                                       |
| Plugin              | A pattern that allows for the addition of new functionalities to a system without modifying its core architecture, often through interfaces or abstract classes. | Use when you want to allow extensibility and adaptability in your application, enabling new features to be added without direct changes to existing code.                                                                                                                                                                                                                                                                                                                    |
| Service Stub        | A lightweight implementation of a service that simulates the behavior of a real service, often used in testing or development environments.                      | Use when you need to test components that depend on external services, allowing for isolated and controlled testing scenarios.                                                                                                                                                                                                                                                                                                                                               |
| Record Set          | A pattern that represents a collection of records or objects, providing methods for querying and manipulating them as a single unit.                             | Use when you need to handle a group of related records together, simplifying operations such as filtering, sorting, or aggregating data.                                                                                                                                                                                                                                                                                                                                     |
### System-level or architectural patterns

| Pattern                                            | Description                                                                                                                                                                  | When to use                                                                                                                                                                                          |
| -------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Event Sourcing                                     | A pattern that stores the state of a system as a sequence of events, capturing all changes and allowing for reconstruction of the current state by replaying these events.   | Use when you need a reliable audit trail of changes, want to support complex state transitions, or need to reconstruct state at any point in time.                                                   |
| CQRS: Command and Query Responsibility Segregation | A pattern that separates the handling of commands (writes) from queries (reads), allowing for optimized models and scalability for both operations.                          | Use when your application has distinct command and query operations that can benefit from different data models or scaling strategies, or when you need to optimize performance for complex queries. |
| Saga: Distributed Transactions                     | A pattern that manages a sequence of local transactions across multiple services, ensuring data consistency and reliability through compensation actions in case of failure. | Use when you need to coordinate transactions across microservices or distributed systems, allowing for eventual consistency while maintaining isolation of services.                                 |
### Domain logic patterns
| Pattern            | Description                                                                                                                                                                      | When to use                                                                                                                                                              |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Transaction Script | A pattern that organizes business logic in a procedural style, where each script represents a single transaction and contains the logic for executing it.                        | Use when you have straightforward business processes with simple operations, allowing for quick implementation without the overhead of more complex architectures.       |
| Domain Model       | A design pattern that represents the conceptual model of the business domain, encapsulating both data and behavior within objects, and focusing on business logic.               | Use when you need a rich representation of complex business logic, where entities have behavior and are closely tied to the business domain. Ideal for evolving systems. |
| Table Module       | A pattern that encapsulates the logic for accessing a database table in a module. Each module contains methods that operate on a single table, treating rows as data structures. | Use when you have a simple domain model where the data structure is straightforward, and the application logic can be handled without rich domain entities.              |
| Service Layer      | A pattern that defines an application’s boundaries and provides a way to encapsulate business logic in services, separating the business logic from the user interface.          | Use when you need to expose business operations to the user interface or other systems, especially in larger applications where the business logic needs to be reusable. |
### Data source & persistence patterns

| Pattern                 | Description                                                                                                                                                                                       | When to use                                                                                                                                                                      |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DAO: Data Access Object | A design pattern that provides an abstract interface to a database or any other persistence mechanism. It separates the data access logic from the business logic.                                | Use when you want to isolate the data layer from the rest of the application, making it easier to manage and test. Ideal for applications with multiple data sources.            |
| Active Record           | A pattern where an object carries both data and behavior related to that data. Each object corresponds to a database row, and methods are provided to persist and retrieve data.                  | Use when you have a straightforward domain model and want to quickly implement CRUD operations without the overhead of a separate data access layer.                             |
| Data Mapper             | A pattern that separates the in-memory objects from the database schema. The Data Mapper handles the transfer of data between objects and the database, allowing for more flexible object models. | Use when you need to maintain a clear separation between your business logic and data access code, especially in complex applications with evolving business rules.              |
| Table Data Gateway      | A pattern that encapsulates the logic for a single database table, providing methods for performing operations on that table.                                                                     | Use when you have a simple data model and want to keep the data access code organized without introducing the complexity of an entire ORM framework.                             |
| Row Data Gateway        | A pattern that represents a single row in a database table as an object, providing methods to interact with the specific row.                                                                     | Use when you need a lightweight approach to handle individual records without the need for a full object representation of the entire table.                                     |
| Repository              | A pattern that abstracts the data access layer, allowing for a collection-like interface to access domain objects. It can work with multiple data sources.                                        | Use when you want to implement a more flexible data access strategy that can evolve, allowing for easier testing and substitution of data sources (e.g., in-memory or database). |
### Object relational patterns

#### Behavioral patterns

| Pattern      | Description                                                                                                                                      | When to use                                                                                                                                                            |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Unit of Work | A design pattern that maintains a list of objects affected by a business transaction and coordinates the writing out of changes to the database. | Use when you need to manage multiple operations in a single transaction, ensuring consistency and reducing database calls. Ideal for complex business processes.       |
| Identity Map | A pattern that ensures that each object is loaded only once per session, maintaining a mapping of object identities to their data in memory.     | Use when you want to avoid loading the same object multiple times during a session, ensuring that changes to objects are reflected consistently and reducing overhead. |
| Lazy Load    | A design pattern that delays the initialization of an object until it is needed, optimizing performance by avoiding unnecessary loading of data. | Use when you have large data sets or related objects that may not always be needed, helping to improve application performance and reduce memory usage.                |
#### Structural patterns

| Pattern                                     | Description                                                                                                                                                     | When to use                                                                                                                                                      |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Identity Field                              | A mapping strategy where an entity has a unique identifier field (usually a primary key) that distinguishes each instance in the database.                      | Use when you need a straightforward way to identify records uniquely, ensuring integrity and easy retrieval in relational databases.                             |
| Foreign Key Mapping                         | A mapping approach that establishes a relationship between tables using foreign keys, allowing for associations between entities.                               | Use when you have clear one-to-one or many-to-one relationships, ensuring referential integrity in your database design.                                         |
| Association Table Mapping                   | A mapping strategy for many-to-many relationships, where an intermediate table (association table) holds references to the primary keys of both related tables. | Use when you need to represent many-to-many relationships clearly, facilitating the management of associations between entities.                                 |
| Dependent Mapping                           | A mapping strategy where an entity’s lifecycle is tied to another entity, often using foreign keys to establish this dependency.                                | Use when you have entities that cannot exist independently and need to be created or deleted alongside their parent entity.                                      |
| Embedded Value/Aggregate Mapping            | A mapping strategy where an object is stored as a single entity, encapsulating related data in a single database column or structure.                           | Use when you have a value object or a set of related attributes that are logically treated as a single unit within your domain model.                            |
| Serialized LOB                              | A mapping approach that stores complex data types (like objects or collections) in a single column as a serialized format (e.g., JSON, XML).                    | Use when you need to persist complex objects that don’t fit neatly into a relational schema, allowing for flexible storage without creating multiple tables.     |
| Single Table Inheritance                    | A mapping strategy where a single table is used to store data for a class hierarchy, using a discriminator column to differentiate between subclasses.          | Use when you have a simple inheritance structure and want to minimize the number of tables, making queries more efficient and straightforward.                   |
| Class Table Inheritance / Root-Leaf Mapping | A mapping approach where each class in an inheritance hierarchy has its own table, with a common base table holding shared attributes.                          | Use when you need to maintain the benefits of inheritance while keeping a clear separation of each class’s attributes, especially useful in complex hierarchies. |
| Concrete Table Inheritance                  | A mapping strategy where each concrete class in an inheritance hierarchy has its own table, without a shared base table, duplicating shared attributes.         | Use when you want to avoid the overhead of joins and can accept some data duplication, suitable for performance-sensitive scenarios.                             |
| Inheritance Mappers                         | A mapping approach that handles the nuances of inheritance mapping, providing strategies to manage how entities inherit attributes and relationships.           | Use when dealing with complex inheritance hierarchies where mapping strategies need to be customized for optimal data retrieval and integrity.                   |
#### Metadata mapping patterns

| Pattern          | Description                                                                                                                                                                | When to use                                                                                                                                                                         |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Metadata Mapping | A pattern that uses metadata to map data between objects and a database schema, often allowing for dynamic object-relational mapping without hardcoding mappings.          | Use when you need flexibility in mapping between objects and database tables, especially in systems with frequently changing schemas or complex data structures.                    |
| Query Object     | A pattern that encapsulates a query, allowing for the creation and execution of database queries in a more object-oriented way. This helps in reusability and readability. | Use when you want to build complex queries programmatically, separate query logic from business logic, and improve testability. Great for applications with dynamic querying needs. |
| Repository       | A pattern that abstracts the data access layer, providing a collection-like interface for accessing domain objects and encapsulating data retrieval logic.                 | Use when you want to decouple your application's business logic from the data access code, promoting a clean separation of concerns and easier unit testing.                        |

### Web presentation patterns

| Pattern                                | Description                                                                                                                                                             | When to use                                                                                                                                                              |
| -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Application Model / Presentation Model | A pattern that separates the presentation logic from the application logic, allowing for a clearer structure and easier testing.                                        | Use when you want to create a clear distinction between the application state and the presentation layer, improving maintainability and testability.                     |
| Humble View / Passive View             | A pattern where the view is a simple interface that only displays data and forwards user input to a presenter. The presenter handles all the logic.                     | Use when you want to keep views simple and ensure that business logic is tested independently from UI logic, promoting separation of concerns.                           |
| MVC: Model View Controller             | A widely-used pattern that separates an application into three interconnected components: Model (data), View (UI), and Controller (input handling).                     | Use when you want to create a clear separation of concerns, making it easier to manage complex applications and facilitating parallel development of components.         |
| MVP: Model View Presenter              | A pattern similar to MVC, but the presenter is responsible for all presentation logic and interacts with both the model and view, allowing for easier testing.          | Use when you want to improve testability by decoupling the view from the model, particularly in applications with complex user interactions.                             |
| MVVM: Model View View-Model            | A pattern that uses data binding to connect the model and view, allowing the view to react to changes in the model without needing to directly manage it.               | Use in applications where data binding is feasible, such as in frameworks like WPF or Angular, allowing for a clean separation of concerns and improved testability.     |
| Front Controller                       | A pattern that centralizes the handling of requests and responses, directing them to the appropriate components.                                                        | Use when you want a unified entry point for request handling, making it easier to manage cross-cutting concerns like logging and authentication.                         |
| Page Controller                        | A pattern where each page in an application has its own controller that handles requests and manages the page's state.                                                  | Use when your application is structured around individual pages, providing a straightforward way to handle page-specific logic.                                          |
| Supervising Controller                 | A variation of the MVC pattern where the controller is responsible for managing the interaction between the view and the model while the view still handles some logic. | Use when you want a more lightweight approach than a full MVP or MVC, allowing some logic to reside in the view while keeping the controller focused on data management. |
| Template View                          | A pattern where the view is defined by a template that is filled with data from the model, allowing for easy reuse of layout and structure.                             | Use when you want to separate presentation from logic and make it easier to manage views, particularly useful in content-driven applications.                            |
| Transform View                         | A pattern where the view transforms the model's data into a format suitable for presentation, often incorporating business logic in the transformation process.         | Use when the presentation layer needs to manipulate data significantly before display, providing flexibility in how data is presented.                                   |
| Top Step View                          | A pattern that allows for a view to orchestrate multiple sub-views or components, managing the overall presentation of a complex UI.                                    | Use in applications with complex UIs that need to combine multiple components into a cohesive whole, improving the organization of the presentation layer.               |

### Distribution patterns

| Pattern              | Description                                                                                                                                                   | When to use                                                                                                                                                 |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Remote Facadate      | A design pattern that provides a simplified interface to a set of remote services, hiding the complexities of network communication and service interactions. | Use when you need to encapsulate and simplify access to remote services, especially when dealing with multiple services or complex communication protocols. |
| Data Transfer Object | A pattern that encapsulates data in a simple object used to transfer data between processes, often across network boundaries, without any business logic.     | Use when you need to transfer large amounts of data efficiently between systems or layers, reducing the number of method calls and improving performance.   |

### Offline concurrency patterns

| Pattern                  | Description                                                                                                                                                                                                                                 | When to use                                                                                                                                                               |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Optimistic Offline Lock  | A concurrency control mechanism where a resource is assumed to be free for updates until a conflict is detected at the time of saving changes. The approach allows multiple transactions to proceed without locking until the commit phase. | Use when conflicts are rare, and you want to allow multiple users to work on the same resource simultaneously, improving performance in low-contention environments.      |
| Pessimistic Offline Lock | A concurrency control strategy that locks a resource for exclusive access as soon as a transaction starts, preventing other transactions from accessing the locked resource until it is released.                                           | Use when conflicts are expected or frequent, and you need to ensure data consistency by preventing simultaneous access, making it suitable for high-contention scenarios. |
| Coarse-Grained Lock      | A locking strategy that locks larger data structures or collections rather than individual records or objects, reducing the overhead of managing many fine-grained locks.                                                                   | Use when the cost of managing many locks outweighs the need for fine-grained control, particularly when operations on related data are performed together frequently.     |

### Session state patterns

| Pattern                | Description                                                                                                                                                             | When to use                                                                                                                                                              |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Client Session State   | Session data is stored on the client side, typically in cookies or local storage. This keeps the server stateless, as it does not need to maintain session information. | Use when you want to minimize server resource usage and keep the application stateless. Ideal for small amounts of session data and when security concerns are managed.  |
| Server Session State   | Session data is stored on the server, often in memory or a session store. The client holds a session identifier (e.g., a cookie) to access their data.                  | Use when you need to manage larger amounts of session data securely, allowing for complex interactions and operations. Suitable for applications with a stateful nature. |
| Database Session State | Session data is stored in a database, allowing for persistence across server restarts and scalability. This can involve using relational or NoSQL databases.            | Use when you require persistent session data that needs to survive server restarts or when scaling out across multiple servers. Great for long-lived sessions.           |

#### Deployment Patterns

| Pattern                         | Description                                                                                                                                                    | When to use                                                                                                                                                                 |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Microservice                    | A pattern where an application is composed of small, independent services that communicate over a network.                                                     | Use when scalability, flexibility in technology, and independent deployment of features are needed. Ideal for complex applications with distinct modules.                   |
| Monoliths and Modular Monoliths | A single-tiered application with all components tightly integrated into one codebase, though a modular monolith is more structured and separated into modules. | Use when simplicity is a priority, with fewer dependencies and easy local testing. Suitable for smaller teams and simpler applications that don’t need distributed scaling. |
| N-Tier Deployment               | An architectural approach that separates an application into multiple logical layers, such as presentation, business, and data layers.                         | Use to separate concerns and organize code in a maintainable structure, especially in traditional applications that benefit from layered design.                            |
| 2-Tier Deployment               | Architecture where the client directly communicates with the server, typically for small applications with minimal business logic.                             | Use when applications require direct communication between client and server, often suitable for smaller or simple applications with low complexity.                        |
| 3-Tier Deployment               | A three-layered architecture with separate presentation, logic, and data layers.                                                                               | Use for traditional web applications needing separation between user interface, application logic, and data management, supporting scalability and modularity.              |
| 4-Tier Deployment               | A four-layered architecture adding an extra layer (e.g., data access) to the 3-tier model to further separate concerns.                                        | Use when more granular separation is needed, typically in complex applications where data access and logic are distinctly managed.                                          |
| Load-Balanced Cluster           | Distributes incoming requests across multiple servers to balance the load and improve reliability and performance.                                             | Use when the application needs to handle high traffic and achieve high availability, such as in large-scale web applications or APIs.                                       |
| Blue/Green Pattern              | A deployment strategy that keeps two identical environments, where one serves production traffic and the other is for testing new releases.                    | Use to minimize downtime and reduce deployment risk, especially useful in environments where updates are frequent and rollback capabilities are essential.                  |
| Rolling Upgrade                 | A deployment technique that updates servers or services one at a time without interrupting the overall system.                                                 | Use when continuous service availability is required during updates, common in applications with many nodes or microservices.                                               |
| Canary Testing                  | A deployment method where a new version is gradually rolled out to a small subset of users before full deployment.                                             | Use when testing changes on a small user group before rolling out to all users, helpful in validating updates with minimal impact.                                          |
| A/B Testing                     | A technique for comparing two versions of an application or feature to determine which performs better based on user interactions.                             | Use when assessing user preferences or behavior between two versions of a feature, often used for UI/UX enhancements and conversion rate optimization.                      |

### Architecture Life-Cycle Activities

The architect needs to worry about the following aspects:
* **Architectural Requirements**
* **Architectural Design**
* **Architectural Documentation**
* **Architectural Evaluation**
* **Architectural Implementation**

![](images/Diagrama%20sin%20título.drawio.svg)

## Architectural Requirements

Architecturally significant requirement (ASR) is a requirement that will have a profound effect on the architecture—that is, the architecture might well be dramatically different in the absence of such a requirement.

Each time you select a pattern or tactic to use in your architecture, you are changing the architecture as a result of the need to meet quality attribute requirements. The more difficult and important the QA requirement, the more likely it is to significantly affect the architecture, and hence to be an ASR. Architecture are mostly driven or shaped by quality attribute requirements.

ASRs often derive from business goals in the development organization itself. "The system shall be modular" or "The system shall exhibit high usability" these are not requirements, they are invitations for the architect to begin a conversation about what requirements in these areas really are.

#### Gathering ASRs from a Requirements Document

Although requirements document won't tell an architect the whole story, they are an important source of ASRs. 

| Design Decision Category             | Look for Requirements Addressing                                                                                                                                                                                                                                                      |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Allocation of Responsibilities       | -Planned evolution of responsibilities, user roles, system modes, major processing steps, commercial packages                                                                                                                                                                         |
| Coordination Model                   | -Properties of the coordination (timeliness, currency, completeness, and consistency)<br>-Names of external elements, protocols, sensors or actuators (devices), middleware, network configuration (including their security properties)<br>-Evolution requirements on the list above |
| Data Model                           | -Processing steps, information flows, major domain entities, access rights, persistence, evolution requirements                                                                                                                                                                       |
| Management of Resources              | -Time, concurrency, memory footprint, scheduling, multiple users, multiple activities, devices, energy usage, soft resources (buffers, queues, etc)<br>-Scalability requirements on the list above                                                                                    |
| Mapping among Architectural Elements | -Plans for teaming, processors, families of processors, evolution of processors, network configurations                                                                                                                                                                               |
| Binding Time Decisions               | -Extension of or flexibility or functionality, regional distinctions, language distinctions, portability, calibrations, configurations                                                                                                                                                |
| Choice of Technology                 | -Named technologies, changes to technologies (planned and unplanned)                                                                                                                                                                                                                  |
#### Gathering ASRs by Interviewing Stakeholders

Say your project isn't producing a requirements document. Gathering this information from stakeholders can be achieved by many methods. One such method is the **Quality Attribute Workshop (QAW).**

The results of stakeholder interviews should include a list of architectural drivers and a set of QA scenarios that the stakeholders (as a group) prioritized. This information can be used to do the following:
* Refine system and software requirements
* Understand and clarify the system's architectural drivers
* Provide rationale for why the architect subsequently made certain design decisions
* Guide the development of prototypes and simulations
* Influence the order in which the architecture is developed

![](images/Pasted%20image%2020241012223742.png)
#### Gathering ASRs by Understanding the Business Goals

Business goals are the raison for building a system. No organization builds a system without a reason.

Business goals are of interest to architect because they often are the precursor or progenitor of requirements that may or may not be captured in a requirements specification but whose achievement signals a successful architectural design. Business goals frequently lead directly to ASRs.

There are three possible relationships between business goals and an architecture:
1. Business goals often lead to quality attribute requirements
2. Business goals may directly affect the architecture without precipitating a quality attribute requirement at all.
3. No influence at all.

![](images/Pasted%20image%2020241012224252.png)


#### A categorization of Business Goals

Business goals are worth capturing explicitly. This is because they often imply ASRs that would otherwise go undetected until it is too late or too expensive to address them.

These categories can be used an aid to brainstorming and elicitation. By employing the list of categories, and asking the stakeholders about possible business goals in each category, some assurance of coverage is gained.

List of standard business goals categories:
1. Contributing to the growth and continuity of the organization
2. Meeting financial objectives
3. Meeting personal objectives
4. Meeting responsibility to employees
5. Meeting responsibility to society
6. Meeting responsibility to state
7. Meeting responsibility to shareholders
8. Managing market position
9. Improving business processes
10. Managing the quality and reputation of products
11. Managing change in environmental factors.
These categories are not completely orthogonal. Some business goals may fit into more than one category, and that's all right. If the categories overlap, then this might cause us to ask redundant questions.

![](images/Pasted%20image%2020241012230158.png)
![](images/Pasted%20image%2020241012230429.png)
#### Expressing Business Goals

It helps ensure that all business goals are expressed clearly, in a consistent fashion, and contain sufficient information to enable their shared understanding by relevant stakeholders. Just as quality attribute scenario adds precision and meaning to an otherwise vague need for say "modifiability" a business goal scenario will ad precision and meaning to a desire to "meet financial objectives". Our business goal scenario template has seven parts:
1. Goal-Source
2. Goal-Subject
3. Goal-Object
4. Environment
5. Goal
6. Goal-Measure
7. Pedigree and value
Elements 2-6 can be combined into a sentence that reads:
* For the system being developed, \<goal-subject\> desires that \<goal-object\> achieve \<goal\> in the context of \<environment\> and will be satisfied it \<goal-measure\>
In many context, the goals of different stakeholders may conflict. By identifying the stakeholder who owns the goal, the sources of conflicting goals can be identified.

![](images/Pasted%20image%2020241012231112.png)


#### Capturing Business Goals

Business goals are worth capturing because they can hold the key to discovering ASRs that emerge in no other context. One method for eliciting and documenting business goals is the Pedigreed Attribute Elicitation Method or PALM. The word "pedigree" means that the business goal has a clear derivation or background. PALM uses the standard list of business goals and the business goal scenario format we described earlier.

PALM can also be used to discover and carry along additional information about existing requirements. Finally PALM can be used to examine particularly difficult quality attribute requirements to see if they can be relaxed.

#### Capturing ASRs in a Utility Tree

To recap, an ASR must have the following characteristics:
* A profound impact on the architecture
* A high business or mission value.

PALM is a seven-step method, nominally carried out over a day and a half in a workshop attended by architects and stakeholders who can speak to the business goals of the organizations involved. The steps are these:
1. PALM overview presentation
2. Business drivers presentation
3. Architecture drivers presentation
4. Business goals elicitation
5. Identification of potential quality attributes from business goals
6. Exercise conclusion
Architects can use a construct called a utility tree for all those purposes. A utility tree begins with the word "utility" as the root node. We then elaborate this root node by listing the major quality attributes that the system is required to exhibit.

Under each quality attribute, record a specific refinement of that QA. For example, performance might be decompose into "data latency" and "transaction throughput". Or it might be decomposed into "user wait time" and "time to refresh web page". The refinements that you choose should be the ones that are relevant to your system. Under each refinement, record the appropriate ASRs (usually expressed as QA scenarios).

Some ASRs might express more than one quality attribute and so might appear in more than one place in the tree. Once the ASRs are recorded and placed in the tree, you can now evaluate them against the two criteria we listed above; the business value of the candidate ASR and the architectural impact of including it. You can use any scale you like, but we find that a simple "H" (high), "M" (medium) and "L" (low) suffice for each criterion.

High designates a must-have requirement, Medium is for a requirement that is important but would no lead to project failure were if omitted. Low describes a nice requirement to have but no something worth much effort.

Once you have a utility tree filled out, you can use it to make important checks. For instance:
* A QA or QA refinement without any ASR is not necessarily an error or omission that needs to be rectified, but it is an indication that attention should be paid to finding out for sure if there are unrecorded ASRs in that area.
* ASRs that rate a (H,H) rating are obviously the ones that deserve the most attention from you. A very large number of these might be a cause for concern about whether the system is achievable
* Stakeholders can review the utility tree to make sure their concerns are addressed.

![](images/Pasted%20image%2020241012233956.png)

#### Tying the Methods Together

How should you employ requirements documents, stakeholder interviews, Quality Attribute Workshops, PALM, and utility trees in concert with each other? The answer to this one is "It depends". If you have a requirements process that gathers, identifies, and prioritizes ASRs, then use that and consider yourself lucky.

If you feel your requirements fall short of this ideal state, then you can ring to bear one or more of the other approaches. For example, if nobody has captured the business goals behind the system you're building, then a PALM exercise would be a good way to ensure that those goals are represented in the system's ASRs.

If you feel that important stakeholders have been overlooked in the requirements-gathering process, then it will probably behoove you to capture their concerns through interviews.

Finally, you can blend all the methods togethers. PALM makes an excellent "subroutine call" from a Quality Attribute Workshop for the step that asks about business goals, and a quality attribute utility tree makes an excellent repository for the scenarios that are the workshop's output.

It is unlikely, however, that your project will have the time and resources to support this do-it-all approach. Better to pick the approach that fills in the biggest gap in your existing requirements: stakeholder representation, business goals manifestation or ASR prioritization.

## Architectural Design

 Architecture design is performed in a series of rounds across the development of a software project. Each design round may take place within a project increment such as a spring. Within these rounds, a number of design iterations are performed. Perhaps the most important characteristic of the ADD method is that it provides detailed, step-by-step guidance on the tasks that have to be performed during the design iterations


Attribute-Driven Design (ADD) is an architectural design method that focuses on the quality attributes of a system. Unlike traditional design methods that may focus only on functionality, ADD emphasizes quality requirements from the beginning. This approach helps create an architecture that better meets the needs and expectations of the system and its users.

![](images/Pasted%20image%2020241109231909.png)
### Step 1: Review Inputs

Before starting a design round, you need to make sure that the inputs to the design process are available and correct. First, you need to ensure that you are clear about the purpose for the design activities that will ensue. 

The purpose may be, for example, to produce, a design for early estimation, to refine an existing design to build a new increment of the system, or to design and generate a prototype to mitigate certain technical risks. 

At this point, we assume that the primary functionality and quality attribute scenarios have been prioritized, ideally by your most important project stakeholders. The drivers really do "drive" design, so getting them right and getting their priority right is crucial.

As a rule of thumb, you should be able to start designing if, besides the design purpose, constraints, and initial architectural concerns, you have established the primary use cases and the most important quality attribute scenarios. This, of course, does not mean you will make decisions focusing on only these drivers: You still need to address other quality attributes scenarios, uses cases, and architectural concerns.

The drivers become part of an architectural design backlog that you should use to perform the different design iterations.

### Step 2: Establish the Iteration Goal by Selecting Drivers

A design round comprises the architecture design activities performed within a development cycle if an iterative development model is used, or the whole set of architecture design activities if a waterfall model is used.

A design round generally takes the form of a series of design iterations, where each iteration focuses on achieving a particular goal. Such a goal typically involves designing to satisfy a subset of the drivers.

For example, an iteration goal could be to create structures from elements that will support a particular performance scenario, or that will enable a use case to be achieved.

For this reason, when performing design, you need to establish a goal before you start a particular design iteration.

Selecting an adequate goal for a design iteration can be challenging. In some cases, the goal may be too small (a unique and relative simple driver is selected) or too big (too many drivers are selected). The following guidelines can help you establish a "right-sized" iteration goal:

* **The goal may be to address a simple important driver:** for example, the architectural concern of decomposing the system or addressing a challenging quality attribute scenario.
* **The goal may be to make decisions to satisfy a set of similar drivers:** for example, making design decisions to address a family of use cases or related quality attribute scenarios.
* **The goal may be to make decisions to satisfy a set of related drivers:** for example, making design decisions to address a user story and an associated quality attribute scenario.
### Step 3: Choose One or More Elements of the System to Refine

The step is where the core design activities start. Satisfying drivers requires you to produce one or more architectural structures. These structures are composed of interrelated elements, and those elements are generally obtained by refining other elements that you previously identified in a earlier iteration.

Refinement can mean decomposition into finer-grained elements (top-down approach), combination of elements into coarser-grained elements (bottom-up approach), or improvement of previously identified elements.

For greenfield development, you can start by establishing the system context and then selecting the only available element— that is, the system itself— for refinement by decomposition. For existing system or for later design iterations in greenfield systems, you would normally choose to refine elements that were identified in prior iterations.

The elements that you will select are the ones that are involved in the satisfaction of specific drivers. You need to have a good understanding of the elements that are part of the as-built architecture of the system.

In some cases you may need to reverse this order. For example, when you are designing a greenfield system or fleshing out certain types of references architectures, you will— at least in the early stages of design—focus on elements of the system and start the iteration by selecting a particular element, only then will you consider the drivers that you want to address.
### Step 4: Choose One or More Design Concepts That Satisfy the Selected Drivers

Choosing the design concepts is probably the most difficult decision you will face in the design process, because it requires you to identify alternatives among design concepts that can be used to achieve your iteration goal, and to select one of these alternatives. Different type of design concepts exist and or each type, there may be many options.


Your major design activities are to identify and select design concepts to address the challenges and drivers that you encounter across the design iterations Design is still an original and creative endeavor, but the creativity resides in the appropriate identification of these existing solutions and then on combining and adapting them to the problem at hand.

To identify which design concepts you need at a particular point (design patterns, tactics, externally developed components). Different points in the design process usually require different types of design concepts.

* For greenfield system in a mature domain, the types of design concepts that will help you initially structure the system are **reference architectures** and **deployment patterns.**

As you progress in the design process, you will use all of the categories of design concepts: tactics, architecture, and design patterns, and externally developed components. Keep. in mind that to address a specific design problem, you can and often will use and combine different types of design concepts:
* For example, when addressing a security driver, you might employ a security pattern, a security tactic, a security framework, or some combination of these.

Once you have more clarity regarding the types of design concepts that you wish to use, you still need to identify alternatives—that is, design candidates. There are several ways to do so, although you will probably use a combination of these techniques rather than just a single method:
* Leverage existing best practices.
* Leverage your own knowledge and experience.
* Leverage the knowledge and experience of others.

Once you have identified a list of alternative design concepts, you need to select which one is the most appropriate to solve the design problem at hand. You can achieve this in a relatively simple way—by creating a table that lists the pros and cons associated with each alternative and selecting one of the alternatives based on those criteria and your drivers. 

Example

| Name of alternative             | Pros                                                 | Cons                                                                                                                                |
| ------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| Monolithic application          | Easier to manage and deploy                          | -Update requires redeployment of the whole application<br>-Horizontal scaling requires creating a replica of the entire application |
| Microservices-based application | Services can be replicated and updated independently | More complex management                                                                                                             |
You may also need to perform a more in-depth analysis to select the best alternative. Methods such as CBAM (cost/benefit analysis method) or SWOT (strengths, weaknesses, opportunities, threats).
### Step 5: Instantiate Architectural Elements, Allocate Responsibilities and Define Interfaces

Once you have selected one or more design concepts, you must make another design decision, which involves **instantiating** elements out of the design concepts that you selected.

Instantiation means adjusting the selected design concepts to the problem at hand.

* For example, if. you selected the Layered Pattern as a design concept, you must decide how many layers will be used, since the pattern itself does not prescribe. a specific number.
* If you selected a particular availability tactic, such as "redundant spare", instantiation implies deciding how this particular tactic will be achieved, such as by adding replication to a particular element.
* In certain cases, instantiation can mean configuration. For example, you may have dedicated an iteration to selecting technologies and associating them with the elements in your design. In further iterations, you might refine these elements. by making finer-grained decisions about how they should be configured. to support a particular driver, such as a quality attribute.

After instantiating the elements, you need to **allocate responsibilities** to each of them. 
* For example for a typical back-end of a web-based enterprise system, at least three layers are usually present: The API layer, the business layer, and the data layer. The responsibilities of these layers differ: The responsibilities of the API layer include exposing endpoints, whereas the responsibilities of the data layer include managing the persistence of data. 
Instantiating elements is just one of the tasks you need to perform to create structures that satisfy a driver or concern. The elements that have been instantiated also need to be connected, thereby enabling them to collaborate with one another. This requires the existence of **relationships** between the elements and the exchange of information through some kind of **interface**.

The activities that are performed in this step are frequently performed by creating some type of diagram, either on a whiteboard or with some diagramming tool. There may be a lot of back and forth micro-iterations among steps 3 and 5.

#### Producing Structures

Design concepts per se won't help you satisfy your drivers unless you produce **structures**; that is, you need to identify and connect elements that are derived from the selected design concepts. This process constitutes the **instantiation** of architectural elements in ADD: creating. elements and relationships between them, and associating responsibilities with these elements. It is important to remember that the architecture of a software system is composed of a set of structures, which can be grouped into three major categories:
* Module structures
* Component and connector structures
* Allocation structures
When you instantiate a design concept, you may actually produce more than one structure.
* For example, in a particular iteration you might instantiate the Layers pattern, which results in a module structure. As part of instantiating this pattern, you will need to choose the number of layers, their relationships, and the specific responsibilities of each layer. As part of this iteration, you might also study how a scenario is supported by the elements that you have just identified. For example, you could create instances of the logical elements in a C&C structure and model how they exchange messages. Finally, you might decide who will be responsible for implementing the modules inside each of the layers, which is an allocation decision.

#### Instantiating Elements

The instantiation of architectural elements depends on the type of design concept that you are working with:

* **Reference architectures:** instantiation typically means that you perform some sort of customization. You will add or remove elements that are part of the structure that is defined by the reference architecture.
* **Architectural and design patterns:** These patterns provide a generic structure composed of elements, their relationships, and their responsibilities. You will need to adapt it to your specific problem. Instantiation usually involves transforming the generic structure defined by the pattern into a specific one that is adapted to the needs of the problem that you are solving.
* **Deployment patterns:** The instantiation of deployment patterns generally involves the identification and specification of infrastructure elements. For example, if you are using a Load-Balanced Cluster pattern, instantiation may involve identifying the number of replicas to be included in the cluster, the load-balancing algorithm, and the physical location of the replicas.
* **Tactics:** You will need to use other design concepts to instantiate a tactic. For example, you might select a security tactic of authenticating actors and instantiate it by creating a custom-coded ad hoc solution, or by using a security pattern, or by using an externally developed component such as security framework.
* **Externally developed components:** The instantiation of these components may or may not imply the creation of new elements. For example, in the case of POO frameworks, instantiation may require you to create specific classes that inherit from the base classes defined in the framework. This will result in new elements. Other approaches, which do not involve the creation of new elements, might include choosing a specific technology from a technology family that was identified in a previous iteration, or specifying configuration options for an element associated with a particular technology (such as a number of threads in a thread pool).
#### Associating Responsibilities and Identifying Properties

When you are creating elements by instantiating design concepts, you need to consider the responsibilities that are allocated to these elements.
* For  example, if you instantiate the Layers pattern and decide to use the traditional three-layer structure, you might decide that one of the layers will be responsible for managing the interactions with the users (typically known as the presentation layer).
When instantiating elements and allocating responsibilities, you should keep in mind the high cohesion/low coupling design principle: Elements should have high cohesion (internally) defined by a narrow set of responsibilities, and low coupling (externally), defined by a lack of knowledge of the implementation details of other elements.

One additional aspect that you need to consider when instantiating design concepts is the properties of the elements. This may involve aspects such as the configuration options, statefulness, resource management, priority or even hardware characteristics of the chosen technologies.

Identifying these properties supports analysis and the documentation of the design rationale.

#### Establishing Relationships Between the Elements

The creation of structures also requires making decisions with respect to the relationships that exist between the elements and their properties.
* Consider the Layer pattern. You may decide that two layers are connected, but these layers will eventually be allocated to components that are, in turn, allocated to hardware. In such case,  you need to decide how communication will take place between these layers, as they have been allocated to components: Is the communication synchronous or asynchronous? Does it involve some type of network communication? Which type of protocol is used? How much information is transferred and at what rate? These design decisions can have a significant with respect to achieving certain quality attributes such as performance.
#### Define Interfaces

Interfaces are the externally visible properties of elements that establish a contractual specification that allows elements to collaborate and exchange infromation. These aree two categories of external and internal

| Interface | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| External  | Include APIs from other system that are required by the system that you are developing and interfaces that are provided by your system to other systems. Required APIs are part of the constraints for your system, as you usually cannot influence their specification.<br><br>Establishing a system context at the beginning of the design process is useful to identify external interfaces. This context can be represented using a system context diagram.<br><br>                                                                     |
| Internal  | Are interfaces between the elements that result form the instantiation of design concepts. To identify the relationships and the interface details, you generally need to understand how the elements exchange information at runtime. You can achieve this with the help of modeling tools such as UML sequence diagrams, where if two elements need to exchange information directly, then a relationship between these elements must exist.<br><br>The information that is exchanged becomes part of the specification of the interface. |
Interfaces typically consist of a set of operations (such as methods) with specified parameters, return values, and possibly, exceptions and pre and post conditions. Some interfaces, however, may involver other information exchange mechanisms, such as a component that writes information to a file or database and another component that hen accesses this information. Interfaces may also establish quality of service agreements.
### Step 6: Sketch Views and Record Design Decisions

At this point, you have completed the design activities for the iteration. The views that you have created are almost certainly incomplete, so these diagrams may need to be revisited and refined in a subsequent iteration. This is typically done to accommodate elements resulting from other design decisions that you will make to support additional drivers. 

In addition to storing the sketches of the views, you should record the significant decisions that are made in the design iteration, and the reasons that led to these decisions to facilitate later analysis and understanding of the decisions. For example, decisions about important tradeoffs might be recorded at this time. During a design iteration, decisions are primarily made in step 4 and step 5. 

In the simplest case, you will produce these sketches on whiteboard, a flip-chart, or even a piece of paper. When you create sketches, you don't need to always use a more formal language as UML. You will need to add a legend to your diagrams to provide clarity and avoid ambiguity.

As you identify an element, you are determining some responsibilities for that element in your mind. Writing it down at the moment ensures that you won't have to remember it later. 

The three purposes of documentation are analysis, construction and education. It is a good idea to remember, as you are documenting, that your design may eventually be analyzed.

During the design process, you should at least try to capture the following elements in a single document:

* The primary presentation: the diagram that represents the structure that you produced
* The element responsibilities table: to help you record the responsibilities of the elements that are present in the structure
* The relevant design decisions and their rationales
You might also capture two other pieces of information
* A runtime representation of the element's interaction—for example a sequence diagram
* The initial interface specification

In each design iteration, you make important design decisions to achieve your iteration goal. These design decisions include the following:
* Selecting a design concept from several alternatives
* Creating structures by instantiating the selected design concept
* Establishing relationships between elements and defining interfaces
* Allocating resources (e.g., people, hardware, computation)
* Others

Recording design decisions beyond the representation of the chosen elements, relationships, and properties is fundamental to help clarify how you arrived at the result: the design rationale.

When your iteration goal involves satisfying a specific quality attribute scenario, some of the decisions that you make will significantly influence your ability to achieve the scenario response measure. To record a minimum of information, you can use a simple table such as that shown in the table:

If you decide to record more than this minimum, the following information can prove useful:
1. What evidence was produced to justify decisions?
2. Who did what?
3. Why were shortcuts taken?
4. Why were tradeoffs made?
5. What assumptions did you make?

| Design Decisions | Rationale and Assumptions |
| ---------------- | ------------------------- |
|                  |                           |

### Step 7: Perform Analysis of Current Design and Rewiew Iteration Goal and Achievement of Design Purpose

Once the design performed in the iteration has been analyzed, you should review the state of your architecture in terms of the established design purpose. This means considering whether you have performed enough design iterations to satisfy the drivers that are associated with the design round, as well as whether the design purpose has been achieved or if additional design rounds are needed in future projects increments. 

When you are performing design, however, you will want to answer several questions:
* How much design do we need to do?
* How much design has been done so far?
* Are we finished?
Agile practices such as the use of backlogs and Kanban boards can help you track the design progress and answer these questions.
### Step 8: Iterate If Necessary

Ideally, you should perform additional iterations and repeat steps 2 to 7 for every driver that was considered as part of the input. What are the criteria for evaluating whether more design iterations are necessary? We let risk be our guide. You should at least have addressed the drivers with the highest priorities. Ideally, you should have assured that the critical drivers are satisfied or, at least, that the design is "good enough" to satisfy them.

Finally, when performing iterative development. you can choose to perform one design round in every project iteration. The initial rounds should focus on addressing the drivers with the highest priorities, while subsequent round focus on making design decisions for other drivers with lower priorities or on new drivers that appear as development progresses.

## Architectural Documentation
## Architectural Implementation
## Architectural Evaluation




#### Documenting Software Architecture

One of the most effective ways of documenting architecture decisions is through **Architecture Decision Records (ADRs)**.

An ADR consist of a short text file (usually one to two pages long) describing a specific architecture decision. While ADRs can be written using plain text, they are usually written in some sort of text document format like AsciiDoc or Markdown.

The basic structure of an ADR consists of five main sections: 
* Title
* Status
* Context
* Decision and Consequence
* Compliance and Notes.
You can store ADRs either in a wiki or in a shared directory file server that can be accessed easily by a wiki or other document rendering software.

#### Choosing the Appropriate Architecture Style

Choosing an architecture style represents the culmination of analysis and thought about trade-offs for architecture characteristics, domain considerations, strategic goals, and a host of other things. Fundamentally, an architect design two things: whatever domain has been specified, and all the other structural elements required to make the system a success.

Architects should go into design decision comfortable with the following things:
* The domain
* Architecture characteristics that impact structure
* Data architecture
* Organizational factors
* Knowledge of process, teams, and operational concerns
* Domain/architecture isomorphism
Taking all these things into account, the architect must make several determinations:
* Monolith versus distributed
* Where should data live
* What communications styles between services—synchronous or asynchronous?

Being pragmatic is taking all of the following factors and constraints into account when creating an architectural solution:
* Budget constraints and other cost-based factors
* Time constraints and other time-based factors
* Skill set and skill level of the development team
* Trade-offs and implications associated with an architecture decision
* Technical limitations of a proposed architectural design or solution

Because components represent a general containership mechanism, an architect can build any type of partitioning they want. In the top-level partitioning , there are two: layered and modular.

These two styles represent different ways to top-level partition the architecture. Note that in each variation, each of the top-level components (layers or components) likely has other components embedded within. The top-level partitioning is of particular of architects because it defines the fundamental architecture style and way of partitioning code.

![](images/Pasted%20image%2020241104161303.png)

| Partitoning            | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Advantages/Disadvantages                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Technical Partitioning | In this partitioning, the system is organized according to technical capabilities, separating modules based on their technical functions or roles in the overall architecture. This often involves specific layers or modules of the technical infrastructure, such as:<br>    - **Presentation Layer**: Handles the user interface and communication with users.<br>    - **Business Logic Layer**: Implements the core business rules and logic.<br>    - **Data Layer**: Manages data access and storage, such as databases and caches.<br>- Technical partitioning is common in layered architectures or in systems where technical functions are clearly defined and can be managed independently.<br><br>Here one component can appears in all the layers. Contrast this with domain partitioning which uses a top-level partitioning, that organizes components by domain rather than technical capabilities | Advantages:<br>-Clearly separates customization code<br>-Aligns more closely to the layered architecture pattern<br><br>Disadvantages:<br>-Higher degree of global coupling. Changes to either the Common or Local component will likely affect all the other components.<br>-Developers may have to duplicate domain concepts in both common and local layers.<br>-Typically higher coupling at the data. In a system like this, the application and data architects would likely collaborate to create a single database, including customization and domains. That in turn creates difficulties in untangling the data relationships if the architects later want to migrate this architecture to a distributed system. |
| Domain Partitioning    | In this partitioning, the system is organized according to business domains or subdomains, aligning with the _Domain-Driven Design_ (DDD) approach. Each module or component is associated with a specific business unit, such as:<br>    - **Sales**: Manages order functionality, billing, and payment processing.<br>    - **Inventory**: Controls tracking and management of stock.<br>    - **Users**: Handles user registration, authentication, and authorization.<br>- Domain partitioning is useful in architectures like microservices, where business modules can be developed, deployed, and scaled independently.                                                                                                                                                                                                                                                                                      | Advantages:<br>-Modeled more closely toward how the business functions rather than an implementation detail<br>-Easier to utilize the Inverse Conway Maneuver to build cross-functional teams around domains<br>-Aligns more closely to the modular monolith and microservices architecture styles<br>-Message flow matches the problem domain<br>-Easy to migrate data and components to distributed architecture<br><br>Disadvantages:<br>-Customization code appears in multiple places.                                                                                                                                                                                                                                |









### 

### Designing an Architecture

We begin by describing our strategy for designing an architecture an then present a packaging of these ideas into a method; The **Attribute-Driven Design** method.
#### Design Strategy

This present three ideas that are key to architecture design methods; decomposition, designing to architecturally significant requirements and generate test
##### Decomposition

The quality attributes are properties of the system as a whole. Given the fact that quality attributes refer to the system as a whole, if we wish to design to achieve quality attribute requirements, we must begin with the system as a whole. As the design is decomposed, the quality attribute requirements can also be decomposed and assigned to the elements of the decomposition.

In some context, the system may end up being constructed mostly from preexisting components; in other, the preexisting components may be a smaller portion of the overall system. In either case, the goal of the design activity is to generate a design that accommodates the constraints and achieves the quality and business goals for the system.
##### Designing to Architecturally Significant Requirements

The ASR are the requirements that drive the architectural design.
1. What about the non-requirements?:  Once you have produced a design that satisfies the ASRs, you know that you are in good shape. However, in the real world, there are other requirements that, while not ASRs, you would like to be able to satisfy. You have three options with respect to meeting these other requirements: (a) you can still meet the other requirements. (b) You can meet the other requirements with a slight adjustment of the existing design, and this slight adjustment does not keep the higher priority requirements from being met. (c) You cannot meet the other requirements under the current design. 
2. Design for all of the ASRs or one at a time: Left to their own devices, novice architects will likely focus on one ASR at a time. But you can do better than that. Eventually, through experience and education, you will develop an intuition for designing, and you will employ patterns to aid you in the designing for multiple ASR.

##### Generate and Test

One way of viewing design is as a process of "generate and test". This approach views a particular design as a hypothesis; namely, the design satisfies the requirements. Testing is the process of determining whether the design hypothesis is correct. If it is not, then another design hypothesis must be generated.

![](images/Pasted%20image%2020241013002319.png)

Generate and test as a design strategy leads to the following questions:
1. Where does the initial hypothesis come from?
2. What are the test that are applied?
3. How is the next hypothesis generated?
4. When are you done?
##### Creating the initial Hypothesis

Design solutions are created using "collateral" that is available to the project. Collateral can include existing system, frameworks available to the project, known architecture patterns, design checklists, or a domain decomposition.

* **Existing systems**: The existing design servers as the initial design hypothesis. The "test" part of this process will reveal the parts that don't work under the current set of requirements and will therefore pinpoint the parts of the system's design that need to change. Another special case is when you have to combine existing legacy systems into a single system.
* **Frameworks**: A framework is a partial design (accompanied by code) that provides services that are common in particular domains. The design of the framework provides the initial design hypothesis.
* **Pattern and tactics**: Cataloged architectural patterns, possibly augmented with tactics, should be considered as candidates for the design hypothesis you're building.
* **Domain decomposition**: Another option for the initial design hypothesis comes from performing a domain decomposition. This decomposition will divide the responsibilities to make certain modifications easier.
* **Design checklists**: These can guide an architect to making quality-attribute-targeted design choices. The checklist will provide guidance and confidence to an architect.
##### Choosing the Test

Three sources provide the test to be applied to the hypothesis:
1. The analysis techniques described before
2. The design checklist
3. The architecturally significant requirements
##### Generating the Next Hypothesis

After applying the test, you might be done—everything looks good. On the other hand, you might still have some concerns; specially you might have a list of quality attribute problems associated with your analysis of the currently hypothesis. This is the problem that tactics are intended to solve. Use the sets of tactics to help you to choose the ones that will improve your design so that you can satisfy these outstanding quality attribute requirements

##### Terminating the Process

You are done with the generate-and-test process when you either have a design that satisfies the ASRs or when you exhaust your budget for producing the design.

If you do not produce such a design within budget, then you have two options depending on the set of ASRs that are satisfied. Your first option is to proceed to implementation with the best hypothesis you were able to produces.

Your second option is to argue for more budget for design and analysis, potentially revisiting some of the major early design decisions and resuming generate and test from that point. If all of the ASRs are critical and you were not able to produce an acceptable or nearly acceptable design, then the system you produce from the design will not be satisfactory and there is no sense in producing it.

### The Attribute-Driven Design Method

This method is a packaging of the strategies. ADD is an iterative method that, at each iteration, helps the architect to do the following:
* Choose a part of the system to design.
* Marshall all the architecturally significant requirements for that part.
* Create and test a design for that part.
The output of ADD is not an architecture complete in every detail, but an architecture in which the main design approaches have been selected and vetted. It produces a workable architecture early and quickly, one that can be given to other project teams so they can begin to work while the architect or architecture team continues to elaborate and refine.

#### Inputs of ADD

ADD can begin when a set of architecturally significant requirement is known. In addition to the ASRs, input to ADD should include a context description. The context description gives you two vital pieces of information as a designer:
1. What are the boundaries of the system being designed? What is inside the system and what is outside the system?
2. What are the external systems, devices, users, and environmental conditions with which the system being designed must interact?
#### Outputs of ADD

The output of ADD is a set of sketches of architectural views. The views together will identify a collection of architectural elements and their relationships or interactions. One of the views produced will be a module decomposition view and that view each element will have an enumeration of its responsibilities listed. Other views will be produced according to the design solutions chosen along the way.

The interactions of the elements are describe in terms of the information being passed between the elements.

The reason we refer to "sketches" above is that ADD does not take the design so far as to include full-blown interface specifications, or even so far as choosing the names and parameter types of the interface programs (methods). That can come later. 

If any aspects of an interface have quality attribute implications, those are captured as annotations. When the method reaches the end, you will have a full-fledged architecture that is roughly documented as a set of views. You can then polish this collection perhaps merging some of the views as appropriate.
#### Step of ADD

ADD is a five-step method:

1. Choose an element of the system to design.
2. Identify the ASRs for the chosen element
3. Generate a design solution for the chosen element
4. Inventory remaining requirements and select the input for the next iteration
5. Repeats steps 1-4 until all the ASRs have been satisfied.

##### Step 1: Choose an Element of the System to Design
\
ADD works by beginning with a part of the system that has not yet been designed and designing it. The "element" to begin with is simply the entire system. The first trip through the ADD steps will yield a broad, shallow design that will produce a set of newly identified architectural elements and their interactions.  These elements will almost certainly require more design decisions to flesh out what they do and how they satisfy the ASRs allocated to them; during the next iteration of ADD, those elements becomes candidates for the "choose element" step.

So, nominally, the first iteration of ADD will create a collection of elements that together constitute the entire system. The second iteration will take on of these elements—what we call "chosen element"—and design it, resulting in still finer-grained elements. The third iteration will take another element—either one of the children of the whole system or one of the children that was created from the design of one of the children of the whole system—and so forth.

There are cases when the first iteration of ADD is different. Perhaps you are not creating a system but evolving an existing one.

There are two main refinement strategies to pursue with ADD: breadth first and depth first. **Breadth first** means to explore all nodes of the same level before reaching the next level. **Depth first**: means to explore so deep in every branch before backtracking.

The order that you should work through ADD is influenced by the business and technical contexts within which the project is operating;
* Personnel availability may dictate a refinement strategy
* Risk mitigation may dictate a refinement strategy
* Deferral of some functionality or quality attribute concerns may dictate a mixed approach.

A breadth-first refinement strategy is preferred because it allows you to apportion the most work to the most teams soonest. Breadth first allows for consideration of the interaction among the elements at the same level.

![](images/Pasted%20image%2020241013135546.png)
##### Step 2: Identify the ASRs for the chosen element

We can use the utility tree here, because it guides the stakeholders in prioritizing the QA requirements. The two factors used to prioritize the ASRss in a utility tree business value and architectural impact.

If the chosen element for design in step 1 is the whole system, then a utility tree can be a good source for the ASRs. Otherwise, construct a utility tree specifically focused on this chosen element, using the quality attribute requirements that apply to this element. Pay attention to the (High, medium) and (Medium, High) utility tree leaves as well. These will almost certainly also be ASRs for this element.
##### Step 3: Generate a design solution for the chosen element

This step is the heart of the ADD. It is the application of the generate-and-test strategy. For each ASR, we develop a solution by choosing a candidate design approach.

Your initial candidate design will likely be inspired by a pattern, possibly augmented by one or more tactics. You may then refine this candidate design by considering the design checklists that we gave for the quality attributes. For ASRs, that correspond to quality attributes, you can invoke those checklists to help you to instantiate or refine the major design approach. that you've chosen.

Although this step is performed for each ASR in turn, the sources of design candidates—patterns, tactics and checklists—will usually do much better than that.

The design decisions made in this step now become constraints on all futures steps of the method.
##### Step 4: Inventory remaining requirements and select the input for the next iteration

It's possible that the design solution you came up with the prior step won't satisfy all the ASRs. Step 4 is a test step that is applied to your design for the element you chose to elaborate in step 1 of this iteration. One of the possible outcomes of step 4 is "backtrack" meaning that an important requirement was not satisfied and cannot be satisfied by further elaborating this design. In this case, the design needs to be reconsidered. The ASRs you have not yet satisfied could be related to the following:
1. A quality attribute requirement allocated to the parent element
2. A functional responsibility of the parent element
3. One or more constraints on the parent element
These kinds of decisions are outside the scope of the ADD method.

Recommended actions for problems with the current hypothesis:
1. Quality attribute requirement: Consider applying more tactics to improve the design with respect to the qualtiy attribute. For each candidate tactic, ask: 
   1. Will this tactic improve the quality attribute behavior of the current design sufficiently?
   2. Should this tactic be used in conjunction with another tactic?
   3. What are the tradeoff considerations when applying this tactic?
2. Functionality responsibility: Add responsibilities either to existing modules or to newly created modules:
   1. Assign the responsibility to a module containing similar responsibilities
   2. Break a module into portions when it is too compelx
   3. Assign the responsibility to a module containing responsibilities with similar quality attribute characteristics—for example, similar timing behavior, similar security requirements or similar availability requirements.
3. Constraint: Modify the design or try to relax the constraint:
   1. Modify the design to accommodate the constraint
   2. Relax the constraint

It can happen the next situations:
1. The quality attribute requirement, functional requirement or constraint has been satisfied.
2. The quality attribute requirement, functional requirement or constraint is delegated to one of the children.
3. The quality attribute requirement, functional requirement or constraint is distributed among the children.
4. the quality attribute requirement, functional requirement or constraint cannot be satisfied with the current design.
##### Step 5: Repeat steps 1-4 until all the ASRs have been satisfied.

After the prior steps, each element has a set of responsibilities, a set of quality attribute requirements, and a set of constraints assigned to it. If it's clear that all of the requirements are satisfied, then this unequivocally ends the ADD process. The ADD process can be terminated when only a sketch of the architecture is available.

On the other hand, if there is a contractual arrangement between your organization and the implementation organization, then the specification of these portion of the system that the implementers are providing must be legally enforceable. This means that the ADD process must continue until that level of specificity has been achieved.

Finally, another condition for terminating ADD is when the project's design budget has been exhausted.

























4
## Architectural Design

Design builds coherent, well-planned representations of programs that concentrate on the interrelationships of parts at a higher level and the logical operations involved at the lower level.

Architectural design represents the structure of data and program components that are required to build a computer-based system. It considers the architectural style that the system will take, the structure and properties of the components that constitute the system, and the relationships that occur among all architectural components of a system.  Where the system architect selects an appropriate architectural style from the requirements derived during software requirements analysis.

Architectural design with data design and then proceeds to the derivation of one or more representations of the architectural structure of the system. Alternative architectural styles or patterns are analyzed to derive the structure that is best suited to customer requirements and quality attributes. Once an alternativa has been selected, the architecture is elaborated using an architectural design method.

The work product is an architecture model encompassing data architecture and program structure is created during architectural design. In addition, component properties and relationships (interactions) are described.


### Establishing the steps

#### 1. Create Architectural Diagrams

**Create Architectural Diagrams**: Visualize the architecture using diagrams (e.g., component diagrams, sequence diagrams) to communicate the design effectively.
#### 2. Define Architectural Context

Establish the system's boundaries, identifying external entities, stakeholders, and how they interact with the system. You can use the Architecture Diagram Context (ADC)

![](images/Pasted%20image%20241001123950.png)

Here the systems that interoperate with the target system (the system for which an architectural design is to be developed) are represented as:
1. Superordinate systems: Those systems that use the target system as part of some higher-level processing scheme.
2. Subordinate systems: Those systems that are used by the target system and provide data or processing that are necessary to complete target system functionality
3. Peer-level systems: Those systems that interact on a peer-to-peer basis (i.e., information is either produced or consumed by the peers and the target system)
4. Actors: Entities (people, devices) that interact with the target system by producing or consuming information that is necessary for requisite processing.
Each of these external entities communicates with the target system through an interface (the small shaded rectangles).
##### 3. Establish defining archetypes

An archetype is a class of pattern that represents a core abstraction that is critical to the design of an architecture for the target system. In general, a relatively small set of archetypes is required to design even relatively complex system.

The target system architecture is composed of these archetypes, which represent stable elements of the architecture but may be instantiated many different ways based on the behavior of the system.

In many cases, archetypes can be derived by examining the analysis classes defined as part of the requirements model. You might define the following archetypes:
* Node: Represents a cohesive collection of input and output elements of a function.
* Detector: An abstraction that encompasses all sensing equipment that feeds information into the target system.
* Indicator: An abstraction that represents all mechanisms for indicating that an alarm condition is occurring.
* Controller: An abstraction that depicts the mechanisms that allow the arming or disarming of a node. If controllers reside on a network, they have the ability to communicate with one another.

![](images/Pasted%20image%2020241001125654.png)

##### 4. Refining the architecture into Components

As the software architecture defined into components, the structure of the system begins to emerge. But how are t hese components chosen?

You begin with classes that were described as part of the requirements model. These analysis classes represent entities within the application (business) domain that must be addressed within the software architecture. Hence, the application domain is one source for the derivation and refinement of components. 

Another source is the infrastructure domain. The architecture must accommodate many infrastructure components that enable application components but have no business connections to the application.

The interfaces depicted in the architecture context diagram imply one or more specialized components that process the data that flows across the interface. In some cases, a complete subsystem architecture with many components must be designed.

The overall architectural structure is represented as UML component diagram.

![](images/Pasted%20image%2020241001131439.png)

##### 5. Describing Instantiations of the System

The context of the system has been represented, archetypes that indicate the important abstractions within the problem, domain have been defined, the overall structure of the system is apparent, and the major software components have been identified. However, further refinement is still necessary.

To accomplish this, an actual instantiation of the architecture is developed. By this we mean that architecture is applied to a specific problem with the intent of demonstrating that the structure and components are appropriate.

![](images/Pasted%20image%2020241001141525.png)

##### 6. Assessing alternative architectural Design

Design results in a number of architectural alternatives that are each assessed to determine which is the most appropriate for the problem to be solved. In the sections that follow, we present two different approaches for the assessment of alternative architectural designs. The first method uses an iterative method to assess design trade-offs. The second approach applies a pseudo-quantitative technique for assessing design quality.

1. The Software Engineering Institute has developed an architecture trade-off analysis method (ATAM) that establishes an iterative evaluation process for software architectures
2. Architectural Reviews are a type of specialized technical review that provide a means of assessing the ability of a software architecture to meet the system's quality requirements and to identify any potential risks. Architectural reviews have the potential to reduce project costs by detecting design problemas early.








## Component-Level Design

In the context of architectural design, a software component can be something as simple as a program module or an object-oriented class, but it can also be extended to include databases and "middleware" that enable the configuration of a network of clients and servers. 

The properties of component are those characteristics that are necessary to an understanding of how the components interact with other components. At the architectural level, internal properties (e.g., details of an algorithm) are not specified. The relationships between components can be as simple as a procedure call form one module to another or as complex as a database access protocol. The objectives of having a design plan are as follows:
- Expose the structure of the system, but hide its implementation details.
- Realize all the use-cases and scenarios.
- Try to address the requirements of various stakeholders.
- Handle both functional and quality requirements.
- Reduce the goal of ownership and improve the organization’s market position.
- Improve quality and functionality offered by the system.
- Improve external confidence in either the organization or system.

Developers should never take components designed by architects as the last words; all software design benefits from iteration. Rather, than initial design should be viewed as first draft, where implementation will reveal more details and refinements.

![](images/Pasted%20image%2020241104162851.png)

| Stage                                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Identifying Initial Components**       | Before any code exists for a software project, the architect must somehow determine what top-level components to begin with, based on what type of top-level partition‐ ing they choose. Outside that, an architect has the freedom to make up whatever components they want, then map domain functionality to them to see where behavior should reside. While this may sound arbitrary, it’s hard to start with anything more concrete if an architect designs a system from scratch. The likelihood of achieving a good design from this initial set of components is disparagingly small, which is why architects must iterate on component design to improve it. |
| **Assign Requirements to Components**    | Once an architect has identified initial components, the next step aligns requirements (or user stories) to those components to see how well they fit. This may entail creating new components, consolidating existing ones, or breaking components apart because they have too much responsibility. This mapping doesn’t have to be exact the architect is attempting to find a good coarse-grained substrate to allow further design and refinement by architects, tech leads, and/or developers.                                                                                                                                                                  |
| **Analyze Roles and Responsibilities**   | When assigning stories to components, the architect also looks at the roles and responsibilities elucidated during the requirements to make sure that the granularity matches. Thinking about both the roles and behaviors the application must support allows the architect to align the component and domain granularity. One of the greatest challenges for architects entails discovering the correct granularity for components, which encourages the iterative approach described here.                                                                                                                                                                        |
| **Analyze Architecture Characteristics** | When assigning requirements to components, the architect should also look at the architectural characteristics discovered earlier to think about how they might impact component division and granularity. For example, while two parts of a system might deal with user input, the part that deals with hundreds of concurrent users will need different architecture characteristics than another part that needs to support only a few. Thus, while a purely functional view of component design might yield a single component to handle user interaction, analyzing the architecture characteristics will lead to a subdivision.                                |
| **Restructure Components**<br>           | Feedback is critical in software design. Thus, architects must continually iterate on their component design with developers. Designing software provides all kinds of unexpected difficulties—no one can anticipate all the unknown issues that usually occur during software projects. Thus, an iterative approach to component design is key. First, it’s virtually impossible to account for all the different discoveries and edge cases that will arise that encourage redesign. Secondly, as the architecture and developers delve more deeply into building the application, they gain a more nuanced understanding of where behavior and roles should lie.  |



![](images/Pasted%20image%2020241104162910.png)




#### Structures and Views

There are different views of the software architecture. Modern systems are frequently too complex to grasp all at once. Instead, we restrict our attention at any one moment to one of the software system's structures. To communicate meaningfully about an architecture, we must make clear which structure or structures we are discussing at the moment—which view we are taking of the architecture.

**A structure**: is a set of elements and the relations among them. There are three categories of structures: Module Structures, Allocation Structures, Component-and-connector structures.
##### Modules Structures

Module structures show how a system is to be structured as a set of code or data units that have to be constructed or procured. Looking at its module views—is an excellent way to reason about a system's modifiability

Modules structures allow us to answer question as these: 
* What is the primary functional responsibility assigned to each module?
* What other software elements is a module allowed to use?
* What other software does it actually use and depend on?
* What modules are related to other modules by generalization or specialization relationships?

Useful modules structures include the following:

| Structure                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Decomposition structure** | The units are modules that are related to each other by the is-a-submodule-of relation, showing how modules are decomposed into smaller modules recursively until the modules are small enough to be easily understood. Modules in this structure represent a common starting point for design, as the architect enumerates what the units of software will have to do and assigns each item to a module for subsequent design and eventual implementation. Modules often have products (such as interface, specifications, code, test, plans, etc) associated with them. The decomposition structure determines, to a large degree, the system's modifiability, by assuring that likely changes are localized. That is, changes fall within the purview of at most a few modules. This structure is often used as the basis for the development project's organization, including the structure of the documentation, and the project's integration and test plans. The units in this structure tend to have names that are organization-specific such as "segment" or "subsystem" |
| **Uses structure**          | In this, the units here are also modules, perhaps classes. The units are related by the uses relation, a specialized form of dependency. A unit of software uses another if the correctness of the first requires the presence of a correctly functioning version of the second. The uses structure is used to engineer systems that can be extended to add functionality, or from which useful functional subsets can be extracted. The ability to easily create a subset of a system allows for incremental development.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **Layer structure**         | The modules in this structure are called layers. A layer is an abstract "virtual machine" that provides a cohesive set of services through a managed interface. Layers are allowed to use other layers in a strictly managed fashion; in strictly layered systems, a layer is only allowed to use the layer immediately below. This structure is used to imbue a system with portability, the ability to change the underlying computing platform.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **Class structure**         | The module ints in this structure are called classes. The relation is inherits form or is an instance of. This view supports reasoning about collections of similar behavior or capability (e.g., the classes that other classes inhering from) and parameterized differences. The class structure allows one to reason about reuse and the incremental addition of functionality. If any documentation exists for a project that has followed an object-oriented analysis and design process, it is typically this structure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Data model**              | The data model describes the static information structure in terms of data entities and their relationships.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
##### Component-and-connector structures

Component-and-connector structures show how the system is to be structured as a set of elements that have runtime behavior (components) and interactions (connectors). They are crucially for system's runtime properties such as performance, security, availability and more.

Component-and-connector views help us, answer questions such as these:
* What are the major executing components and how do they interact at runtime?
* What are the major shared data stores?
* Which parts of the system are replicated?
* How does data progress through the system?
* What parts of the system can run in parallel?
* Can the system's structure change as it executes, and if so, how?

Useful C&C structures include the following:

| Structure                 | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Service structure**     | The units here are services that interoperate with each other by. service coordination mechanisms such as SOAP. The service structure is an important structure to help engineer a system composed of components that may have been developed anonymously and independently of each other.                                                                                                                                                                                                                                                        |
| **Concurrency structure** | This structure allows the architect to determine opportunities for parallelism and the locations where resource contention may occur. The units are components and the connectors are their communication mechanisms. The components are arranged into logical threads; a logical thread is a sequence of computations that could be allocated to a separate threat later in the design process. The concurrency structure is early in the design process to identify the requirements to manage the issues associated with concurrent execution. |
##### Allocation Structures

Allocation structures show how the system will relate to non-software structures and its environment (such as CPUS, file system, networks, development teams, etc). 

Allocation structures help us answer questions such as these:
* What processor does each software element execute on?
* In what directories or files is each element stored during development, testing, and system building?
* What is the assignment of each software element to development teams?

Useful allocation structures include these:

| Structure                     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Deployment structure**      | The deployment structure shows how software is assigned to hardware processing and communication elements. The elements are software elements, hardware entities (processors), and communication pathways. Relations are allocated-to, showing on which physical units the software, and migrates-to if the allocation is dynamic. This structure can be used to reason about performance, data integrity, security and availability. It is of particular interest in distributed and parallel systems. |
| **Implementation structure**  | This structure shows how software elements (usually modules) are mapped to the file structure(s) in the system's development, integration, or configuration control environments. This is critical for the management of development activities and build processes.                                                                                                                                                                                                                                    |
| **Work assignment structure** | This structure assigns responsibility for implementing and integrating the modules to the teams who will carry it out. Having a work assignment structure be part of the architecture makes it clear that the decision about who does the work has architectural as well as management implications.                                                                                                                                                                                                    |

Structures represent the primary engineering leverage points of an architecture. Each structure brings with it the power to manipulate one or more quality attributes.


![](images/Pasted%20image%2020241005134551.png)




|                       | Software Structures | Element Types                  | Relations                                                                       | Useful for                                                                                                         | Quality Attributes Affected               |
| --------------------- | ------------------- | ------------------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ----------------------------------------- |
| Module Structures     | Decomposition       | Module                         | Is a submodule of                                                               | Resource allocation and project structuring and planning; information hiding; encapsulation; configuration control | Modifiability                             |
|                       | Uses                | Module                         | Uses (i.e., requires the correct presence of)                                   | Engineering subsets, engineering extensions                                                                        | Subsetability, extensibility, portability |
|                       | Layers              | Layer                          | Requires the correct presence of, uses the services of, provides abstraction to | Incremental development, implementing systems on top of "virtual machines"                                         | Portability                               |
|                       | Class               | Class, Object                  | Is an instance of, shares access methods of                                     | In object-oriented design systems, factoring out commonanlity; planning extensions of functionality                | Modifiability, extensibility              |
|                       | Data model          | Data entity                    | {one, many}-to{one,many}, generalizes, specializes                              | Engineering global data structures for consistency and performance                                                 | Modifiability, performance                |
| C&C Structures        | Service             | Service, ESB, registry, others | Runs concurrently with, may run concurrently with, excludes, precedes, etc.     | Scheduling analysis, performance analysis                                                                          | Interoperability, modifiability           |
|                       | Concurrency         | Processes, threads             | Can run in parallel                                                             | Identifying locations where resource contention exists, or where threads may fork, join, be created, or be killed  | Performance, availability                 |
| Allocation Structures | Deployment          | Components, hardware elements  | Allocated to, migrates to                                                       | Performance, availability, security analysis                                                                       | Performance, security, availability       |
|                       | Implementation      | Modules, file structure        | Stored in                                                                       | Configuration control, integration, test activities                                                                | Development efficiency                    |
|                       | Work assignment     | Modules, organizational units  | Assigned to                                                                     | Project management, best use of expertise and available resources, management of commonality                       | Development efficiency                    |


**A view** is a representation of a coherent set of architectural elements, as written by and read by system stakeholders. A view is a representation of one or more structures.

The concept of views gives us our most fundamental principle of architecture documentation:
* Documenting an architecture is a matter of documenting the relevant views and then adding documentation that applies to more than one view.

Different views support different goals and uses. This is why we do not advocate a particular view or collection of views. The views you should document depend on the uses you expect to make of the documentation. Different views will highlight different system elements and relations. How many different views to represent is the result of a cost/benefit decision.

Views may be driven by the need to document a particular pattern in your design. Some patterns are composed of modules, other of components and connectors, and still others have deployment considerations. Module views, component-and-connector (C&C) views, and allocation views are the appropriate mechanisms for representing these considerations.

##### Module View

A module is an implementation unit that provides a coherent set of responsibilities. A module might take the form of a class, a collection of classes, a layer, an aspect, or any decomposition of the implementation unit. 

Example module views are decomposition, uses, and layers. Every module has a collection of properties assigned to it. These properties are intended to express the important information associated with the module, as well as constraints on the module. Sample properties are responsibilities, visibility information, and revision history. The relations that modules have to one another include *is part of*, *depends on*, and *is a*.

Module structures often determine how changes to one part of a system might affect other parts, and hence the ability of a system to support modifiability, portability, and reuse.

It is unlikely that the documentation of any software architecture can be complete without at least one module view.

Summary of the module views 

| Concept     | Description                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Elements    | **Modules**, which are implementation units of software that provide a coherent set of responsibilities                                                                                                                                                                                                                                                                                                                        |
| Relations   | -**Is part of**: which defines a part/whole relationship between the submodule—the part— and the aggregate module—the whole<br>-**Depends on**: which defines a dependency relationship between two modules. Specific module views elaborate what dependency is meant<br>-**Is a**: which defines a generalization/specialization relationship between a more specific module—the child— and a more general module—the parent. |
| Constraints | Different module views may impose specific topological constraints, such as limitations on the visibility between modules.                                                                                                                                                                                                                                                                                                     |
| Usage       | -Blueprint for construction of the code<br>-Change-impact analysis<br>-Planning incremental development<br>-Requirements traceability analysis<br>-Communicating the functionality of a system and the structure of its code base<br>-Supporting the definition of work assignments, implementation schedules and budget information<br>-Showing the structure of information that the system needs to manage                  |

The list of properties may vary but is likely to include the following:
* **Name**:  A module's name may reflect its position in a decomposition hierarchy, the name A.B.C.
* **Responsibilities**: The responsibility property for a module is a way to identify its role in the overall system and establishes an identify for it beyond the name.
* **Visibility of interface(s)**
* **Implementation information**: It is therefore useful to record information related to their implementation from the point of view of managing their development and building the system that contains them.
* **Mapping to source code units**: This identifies the files that constitute the implementation of a module.
* **Test information**: The module's test plan, test cases, test scaffolding, and test data are important to document.
* **Management information**: A manager may need information about the module's predicted scheduled and budget.
* **Implementation constraints**
* **Revision history**

Module views that show dependencies among modules or layers provide a good basis for change-impact analysis.

A module view can be used to explain the system's functionality to someone not familiar with it. The various levels of granularity of the module decomposition provide a top-down presentation of the system's responsibilities and therefore can guide the learning process. 

On the other hand, it is difficult to use the module views to make inferences about runtime behavior, because these views are just a static partition of the functions of the software. Module view is not typically used for analysis of performance, reliability and many other runtime qualities. For those, we rely on component-and-connector and allocation views.

Module views are commonly mapped to component-and-connector views. The implementation units shown in module-views have a mapping to components that execute at runtime.

Module views also provide the software elements that are mapped to the diverse nonsoftware elements of the system environment in the various allocation views.
##### Component-and-connector View

These show elements that have some runtime presence, such as processes, objects, clients, servers and data stores. These elements are termed components. Additionally, this views include as elements, the pathways of interaction, such as communication links and protocols, information flows, and access to shared storage. Such interactions. are presented as connector in C&C views.

 Components have interfaces called ports. A port defines a point of potential interaction of a component with its environment.

In this respect ports differ from interfaces of modules, whose interfaces are never replicated. You can annotate a port with a number or range of numbers to indeicate replication.

A component in a C&C view may represent a complex subsystem, which itself can be describe as a C&C subarchitecture.

Connectors are the other kind of element in a C&C view. Connector often represent much more complex form of interaction.

Connectors have roles, which are its interfaces, defining the ways in which the connector may be used by components to carry out interaction. Like components ports, connector roles differ from modules interfaces in that they can be replicated , indicating how many components can be involved in its interactions.

Like components, complex connectors may in turn be decomposed into collections of components and connectors that describe the architectural substructure of those connectors.

Connectors embody a protocol interaction. When two or more components interact, they must obey conventions about order of interactions, locus of control, and handling of error conditions and timeouts. The protocol of interaction should be documented.

The primary relation within a C&C is attachment. Attachments indicate which connectors are attached to which components, thereby defining a system as a graph of components and connectors. Specially, an attachment is denoted by associating (attaching) a component's port to connector's role.

Compability often is defined in terms of information type and protocol. An element (component or connector) of a C&C view will have various associated properties. Every element should have a named and type. Additional properties depend on the type of component or connector. 

The following are examples of some typical properties their uses:
* Reliability
* Performance
* Resource requirements
* Functionality
* Security
* Concurrency
* Modifiability
* Tier

Summary of Component-and-Connector views

| Concept     | Description                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Elements    | -**Components**: Principal processing units and data stores. A component has a set of ports through which it interacts with other components (via connectors)<br>-**Connectors**: Pathways of interaction between components. Connectors have a set of roles (interfaces) that indicate how components may use a connector in interactions.                                                                                         |
| Relations   | -**Attachments**: Component ports are associated with connector roles to yield a graph of components and connectors.<br>-**Interface delegation**: In some situations component ports are associated with one or more ports in an "internal" subarchitecture. The case is similar for the roles of a connector.                                                                                                                     |
| Constraints | -Components can only be attached to connectors, not directly to other components<br>-Connectors can only be attached to components, not directly to other connectors<br>-Attachments can only be made between compatible ports and roles<br>-Interface delegation can only be defined between two compatible ports (or two compatible roles)<br>-Connectors cannot appear in isolation: a connector must be attached to a component |
| Usage       | -Show how the system works<br>-Guide development by specifying the structure and behavior of runtime elements<br>-Help reason about runtime system quality attributes, such as performance and availability                                                                                                                                                                                                                         |

##### Allocation View

Allocation views describe the mapping of software units to elements of an environment in which the software is developed or in which it executes. The environment might be the hardware, the operating environment in which the software is executed, the file systems supporting development or deployment, or the development organization(s).

Summary of the Characteristics of Allocation Views

| Concept     | Description                                                                                                                                                                                                                                                                                   |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Elements    | -Software element: A software element has properties that are required of the environment<br>-Environmental element: An environmental element has properties that are provided to the software                                                                                                |
| Relations   | -Allocated to: A software element is mapped (allocated to) an environmental element. Properties are dependent on the particular view                                                                                                                                                          |
| Constraints | Varies by view                                                                                                                                                                                                                                                                                |
| Usage       | -For reasoning about performance, availability, security and safety.<br>-For reasoning about distributed development and allocation of work to teams<br>-For reasoning about concurrent access to software versions.<br>  -For reasoning about the form and mechanisms of system installation |

The usual goal of an allocation view is to compare the properties required by the software element with the properties provided by the environmental elements to determine whether the allocation will be successful or not.

Allocation views can depict state or dynamic views. A static view depicts a fixed allocation of resources in a environment. A dynamic view depicts the conditions and the triggers for which allocation of resources changes according to loading

##### Quality Views

However, in systems in which certain quality attributes are particularly important and pervasive, structural views may not be the best way to present the architectural solution to those needs. Quality view can be tailored for specific stakeholders or to address specific concerns. These quality views are formed by extracting the relevant pieces of structural views and packaging them together:
* A security view
* A communications view
* An exception or error-handling view
* A reliability view
* A performance view





Component level design occurs after the first iteration or architectural design has been completed. At this stage, the overall data and program structure of the software has been established.

A complete set of software components is defined during architectural design. But the internal data structures and processing details of each component are not represented at a level of abstraction that is close to code.

Component-level design defines that data structures, algorithms, interface characteristics, and communication mechanisms allocated to each software component.

The component-level design allows you to review the details of the design for correctness and consistency with other design representations.  It provides a means for assessing whether data structures, interfaces, and algorithms will work.

Design representations of data, architecture, and interfaces form the foundation for component-level design. The class definition or processing narrative for each component is translated into a detailed design that makes use of diagrammatic of text-based forms that specify internal data structures, local interface detail, and processing logic. Design notation encompasses UML diagrams and supplementary forms. Procedural design is specified using a set of structure programming constructs. It if often possible to acquire existing reusable software components rather than building new ones.

The work product is the design for each component, represented in graphical, tabular, or text-based notation, is the primary work product produced during component-level design.

In the context of traditional software engineering a component is a functional element of a program that incorporates processing logic, the internal data structures that are required to implement the processing logic, and an interface that enables the component to be invoked and data to be passed to it. A traditional component also called **module** resides within the software architecture and serves one of three important roles:
1. Control component that coordinates the invocation of all other problem domains components
2. A problem domain component that implements a complete or partial function that is required by the customer
3. An infrastructure component that is responsible for functions that support the processing required in the problem domain.
Traditional software components are derived from the analysis model. Each component represented the component hierarchy is mapped into a module hierarchy.
Control components (modules) reside near the top of the hierarchy and problema domain components tend to reside toward the bottom of the hierarchy.

##### Conducting component-level design

1. Identify all design classes that correspond to the problem domain
2. Identify all design class that correspond to the infrastructure domain
3. Elaborate all design classes that are not acquired as reusable components
4. Specify message details when classes or componentes collaborate
5. Elaborate attributes and define data types and data structures required to implement them
6. Describe processing flow within each operation in detail
7. Describe persistent data sources (database and files) and identify the classes required to manage them 
8. Develop and elaborate behavioral representations for a class or component 
9. Refactor every component-level design representation and always consider alternatives








### Architecture Design Process

The architecture design process focuses on the decomposition of a system into different components and their interactions to satisfy functional and nonfunctional requirements. The key inputs to software architecture design are:
- The requirements produced by the analysis tasks.
- The hardware architecture (the software architect in turn provides requirements to the system architect, who configures the hardware architecture).
The result or output of the architecture design process is an **architectural description**. The basic architecture design process is composed of the following steps −

A software architecture must describe its group of components, their connections, interactions among them and deployment configuration of all components.

A software architecture can be defined in many ways −
- **UML (Unified Modeling Language)** − UML is one of object-oriented solutions used in software modeling and design.
- **Architecture View Model (4+1 view model)** − Architecture view model represents the functional and non-functional requirements of software application.
- **ADL (Architecture Description Language)** − ADL defines the software architecture formally and semantically.

#### Understand the Problem
- This is the most crucial step because it affects the quality of the design that follows.
- Without a clear understanding of the problem, it is not possible to create an effective solution.
- Many software projects and products are considered failures because they did not actually solve a valid business problem or have a recognizable return on investment (ROI).
#### Identify Design Elements and their Relationships
- In this phase, build a baseline for defining the boundaries and context of the system.
- Decomposition of the system into its main components based on functional requirements. The decomposition can be modeled using a design structure matrix (DSM), which shows the dependencies between design elements without specifying the granularity of the elements.
- In this step, the first validation of the architecture is done by describing a number of system instances and this step is referred as functionality based architectural design.
#### Evaluate the Architecture Design
- Each quality attribute is given an estimate so in order to gather qualitative measures or quantitative data, the design is evaluated.
- It involves evaluating the architecture for conformance to architectural quality attributes requirements.
- If all estimated quality attributes are as per the required standard, the architectural design process is finished.
- If not, the third phase of software architecture design is entered: architecture transformation. If the observed quality attribute does not meet its requirements, then a new design must be created.
#### Transform the Architecture Design
- This step is performed after an evaluation of the architectural design. The architectural design must be changed until it completely satisfies the quality attribute requirements.
- It is concerned with selecting design solutions to improve the quality attributes while preserving the domain functionality.
- A design is transformed by applying design operators, styles, or patterns. For transformation, take the existing design and apply design operator such as decomposition, replication, compression, abstraction, and resource sharing.
- The design is again evaluated and the same process is repeated multiple times if necessary and even performed recursively.
- The transformations (i.e. quality attribute optimizing solutions) generally improve one or some quality attributes while they affect others negatively

#### Structural Diagrams

Structural diagrams represent the static aspects of a system. These static aspects represent those parts of a diagram which forms the main structure and is therefore stable.

### The 4+1 View Model

The 4+1 View Model was designed by Philippe Kruchten to describe the architecture of a software–intensive system based on the use of multiple and concurrent views. It is a **multiple view** model that addresses different features and concerns of the system. It standardizes the software design documents and makes the design easy to understand by all stakeholders.

It is an architecture verification method for studying and documenting software architecture design and covers all the aspects of software architecture for all stakeholders. It provides four essential views:

- **The logical view or conceptual view**: It describes the object model of the design.
- **The process view**: It describes the activities of the system, captures the concurrency and synchronization aspects of the design.
- **The physical view**: It describes the mapping of software onto hardware and reflects its distributed aspect.
- **The development view**: It describes the static organization or structure of the software in its development of environment.
This view model can be extended by adding one more view called **scenario view** or **use case view** for end-users or customers of software systems. It is coherent with other four views and are utilized to illustrate the architecture serving as “plus one” view, (4+1) view model. The following figure describes the software architecture using five concurrent views (4+1) model.

![](images/Pasted%20image%2020241001231011.png)


###### Why is it called 4+1 instead of 5?

The **use case view** has a special significance as it details the high level requirement of a system while other views details — how those requirements are realized. When all other four views are completed, it’s effectively redundant. However, all other views would not be possible without it. The following image and table shows the 4+1 view in detail:

![](images/Pasted%20image%2020241001231131.png)

#### Architecture Description Languages (ADLs)

An ADL is a language that provides syntax and semantics for defining a software architecture. It is a notation specification which provides features for modeling a software system’s conceptual architecture, distinguished from the system’s implementation.

ADLs must support the architecture components, their connections, interfaces, and configurations which are the building block of architecture description. It is a form of expression for use in architecture descriptions and provides the ability to decompose components, combine the components, and define the interfaces of components.

An architecture description language is a formal specification language, which describes the software features such as processes, threads, data, and sub-programs as well as hardware component such as processors, devices, buses, and memory.

It is hard to classify or differentiate an ADL and a programming language or a modeling language. However, there are following requirements for a language to be classified as an ADL
- It should be appropriate for communicating the architecture to all concerned parties.
- It should be suitable for tasks of architecture creation, refinement, and validation.
- It should provide a basis for further implementation, so it must be able to add information to the ADL specification to enable the final system specification to be derived from the ADL.
- It should have the ability to represent most of the common architectural styles.
- It should support analytical capabilities or provide quick generating prototype implementations.

The object-oriented (OO) paradigm took its shape from the initial concept of a new programming approach, while the interest in design and analysis methods came much later. OO analysis and design paradigm is the logical result of the wide adoption of OO programming languages.




![](images/Pasted%20image%2020241001232110.png)


![](images/Pasted%20image%2020241001234749.png)





### Component-Based Software Engineering


The CBSE process, however, must be characterized in a manner that not only identifies candidate components but also qualifies each component’s interface, adapts components to remove architectural mismatches, assembles components into a selected architectural style, and updates components as requirements for the system change.

The process model for component-based software engineering emphasizes parallel tracks in which domain engineering occurs concurrently with component-based development. Domain engineering performs the work required to establish a set of software components that can be reused by the software engineer.

![](images/Pasted%20image%2020241002120848.png)

#### Process

On the surface, CBSE seems quite similar to conventional or object-oriented software engineering. The process begins when a software team establishes requirements for the system to be built using conventional requirements elicitation techniques. An architectural design is established, but rather than moving immediately into more detailed design tasks, the team examines requirements to determine what subset is directly amenable to composition, rather than construction. That is, the team asks the following questions for each system requirement: 
* Are commercial off the shelf components available to implement the requirement? 
* Are internally reusable components available to implement the requirement? 
* Are the interfaces of the available components compatible with the architecture of the system to be built? 
The team attempts to modify or remove those system requirements that cannot be implemented with COTS or in-house components. If the requirement(s) cannot be changed or deleted, conventional or object-oriented software engineering methods are applied to develop those new components that must be engineered to meet the requirement(s). 
But for those requirements that are addressed with available components, a different set of software engineering activities commences: 
* **Component Qualification**: System requirements and architecture define the components that will be required. Reusable components (whether COTS or inhouse) are normally identified by the characteristics of their interfaces. That is, “the services that are provided, and the means by which consumers access these services” *BRO96+ are described as part of the component interface. But the interface does not provide a complete picture of the degree to which the component will fit the architecture and requirements. The software engineer must use a process of discovery and analysis to qualify each component’s fit
* **Component Adaptation**: we noted that software architecture represents design patterns that are composed of components (units of functionality), connections, and coordination. In essence the architecture defines the design rules for all components, identifying modes of connection and coordination. In some cases, existing reusable components may be mismatched to the architecture’s design rules. These components must be adapted to meet the needs of the architecture or discarded and replaced by other, more suitable components
* **Component Composition**: Architectural style again plays a key role in the way in which software components are integrated to form a working system. By identifying connection and coordination mechanisms (e.g., run-time properties of the design), the architecture dictates the composition of the end product.
* **Component Update**: When systems are implemented with COTS components, update is complicated by the imposition of a third party (i.e., the organization that developed the reusable component may be outside the immediate control of the software engineering organization)

In addition to COTS components, the CBSE process yields: 
* Qualified components: Assessed by software engineers to ensure that not only functionality, but performance, reliability, usability, and other quality factors (Chapter 19) conform to the requirements of the system or product to be built. 
* Adapted components: Adapted to modify (also called mask or wrap) [BRO96] unwanted or undesirable characteristics.
* Assembled components: Integrated into an architectural style and interconnected with an appropriate infrastructure that allows the components to be coordinated and managed effectively.
* Updated components: Replacing existing software as new versions of components become available

#### Domain Analysis Process (DAP)

The steps in the process are:
1. Define the domain to be investigated 
2. Categorize the items extracted from the domain 
3. Collect a representative sample from the application 
4. Analyze each application in the sample 
5. Develop an analysis model for the objects 
It is important to note that domain analysis is applicable to any software engineering paradigm and may be applied for conventional as well as object-oriented development. Prieto Diaz suggested an eight-step approach to the identification of the reusable components 
1. Select specific functions or the objects 
2. Abstract functions or object
3. Define a taxonomy 
4. Identify common features 
5. Identify specific relationship 
6. Abstract the relationship 
7. Derive a functional model 
8. Define a domain language
Although the steps just noted provide a useful model for domain analysis, they provide no guidance for deciding which software components are candidates for reuse. Hutchinson and Hindley suggest the following set of pragmatic questions as a guide for identifying reusable software components:
* Is component functionality required on future implementations?
* How common is the component's function within the domain?
* Is there duplication of the component's function within the domain?
* Is the component hardware dependent?
* Does the hardware remain unchanged between implementations?
* Can the hardware specifics be removed to another component?
* Is the design optimized enough for the next implementation?
* Can we parameterize a non-reusable component so that it becomes reusable?
* Is the component reusable in many implementations with only minor changes?
* Is reuse through modification feasible?
* Can a non-reusable component be decomposed to yield reusable components?
* How valid is component decomposition for reuse?


##### Analysis and Design for Reuse:

Data, functional, and behavioral models (represented in a variety of different notations) can be created to describe what a particular application must accomplish. Written specifications are then used to describe these models. A complete description of requirements is the result. Ideally, the analysis model is analyzed to determine those elements of the model that point to existing reusable components. 

The problem is extracting information from the requirements model in a form that can lead to “specification matching.” Bellinzoni, Gugini, and Pernici describe one approach for object-oriented systems: Components are defined and stored as specification, design, and implementation classes at various levels of abstraction— with each class being an engineered description of a product from previous applications. 

The specification knowledge—development knowledge—is stored in the form of reuse-suggestion classes, which contain directions for retrieving reusable components on the basis of their description and for composing and tailoring them after retrieval. As we have already noted, DFR requires the software engineer to apply solid software design concepts and principles. But the characteristics of the application domain must also be considered. Binder suggests a number of key issues that form a basis for design for reuse: 
* Standard data: The application domain should be investigated and standard global data structures (e.g., file structures or a complete database) should be identified. All design components can then be characterized to make use of these standard data structures. 
* Standard interface protocols: Three levels of interface protocol should be established: the nature of intra-modular interfaces, the design of external technical (nonhuman) interfaces, and the human/machine interface. 
* Program templates: The structure model can serve as a template for the architectural design of a new program.









CHATGPT VERSION : "
- **Define Architectural Objectives**: Clarify the goals and priorities for the architecture, considering both functional and non-functional requirements.
- **Select Architectural Styles and Patterns**: Choose appropriate styles (e.g., layered, microservices) and design patterns that suit the system's needs.
- **Identify Key Components**: Determine the main components or modules of the architecture, outlining their responsibilities.
- **Define Interfaces and Interactions**: Specify how components will communicate, including APIs, protocols, and data formats.
- **Establish Data Management Strategies**: Decide on data storage solutions, data flow, and how data will be accessed and manipulated.
- **Assess Quality Attributes**: Analyze how the design will meet quality attributes like scalability, performance, security, and maintainability.
- **Create Architectural Diagrams**: Visualize the architecture using diagrams (e.g., component diagrams, sequence diagrams) to communicate the design effectively.
- **Review and Validate Design**: Conduct design reviews with stakeholders to gather feedback and ensure alignment with requirements.
- **Iterate on Design**: Refine the architecture based on feedback, ensuring it evolves to meet changing requirements or new insights.

## Implementation

Coding the software. Developers translate the design into a programming language, creating the final product.
## Testing

Verifying that the software functions correctly and meets the requirements. This includes unit testing, integration testing, and acceptance testing.
## Deployment

Installing and configuring the software in the end-user environment. It may include user training and initial support.
## Maintenance

Updating and improving the software after its release. This includes bug fixing, adjustments, and adaptations to new needs.
## Project Management

Coordinating and planning all activities, resources, and timelines involved in software development.

## Anti patterns for every phase
